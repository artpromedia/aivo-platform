/**
 * AIVO i18n CLI - JSON/POT Output Generators
 *
 * Generates translation output files in various formats.
 */

import * as fs from 'fs/promises';
import * as path from 'path';

import type { ExtractedKey } from './extractor.js';

export interface OutputOptions {
  outputDir: string;
  format: 'json' | 'pot' | 'arb';
  locales?: string[];
  flat?: boolean;
}

/**
 * Generate output files from extracted keys
 */
export async function generateOutput(keys: ExtractedKey[], options: OutputOptions): Promise<void> {
  const { outputDir, format, locales = ['en'] } = options;

  await fs.mkdir(outputDir, { recursive: true });

  switch (format) {
    case 'json':
      await generateJSON(keys, outputDir, locales, options.flat);
      break;
    case 'pot':
      await generatePOT(keys, outputDir);
      break;
    case 'arb':
      await generateARB(keys, outputDir, locales);
      break;
  }
}

/**
 * Generate JSON translation files
 */
async function generateJSON(
  keys: ExtractedKey[],
  outputDir: string,
  locales: string[],
  flat = false
): Promise<void> {
  // Group by namespace
  const namespaces = new Map<string, ExtractedKey[]>();
  for (const key of keys) {
    const ns = key.namespace ?? 'common';
    const existing = namespaces.get(ns) ?? [];
    existing.push(key);
    namespaces.set(ns, existing);
  }

  for (const locale of locales) {
    const localeDir = path.join(outputDir, locale);
    await fs.mkdir(localeDir, { recursive: true });

    for (const [namespace, nsKeys] of namespaces) {
      const filePath = path.join(localeDir, `${namespace}.json`);

      // Try to read existing file
      let existing: Record<string, unknown> = {};
      try {
        const content = await fs.readFile(filePath, 'utf-8');
        existing = JSON.parse(content);
      } catch {
        // File doesn't exist, start fresh
      }

      // Merge new keys
      const output = flat ? buildFlatJSON(nsKeys, existing) : buildNestedJSON(nsKeys, existing);

      await fs.writeFile(filePath, JSON.stringify(output, null, 2) + '\n');
    }
  }
}

/**
 * Build flat JSON structure
 */
function buildFlatJSON(
  keys: ExtractedKey[],
  existing: Record<string, unknown>
): Record<string, string> {
  const result: Record<string, string> = { ...existing } as Record<string, string>;

  for (const key of keys) {
    if (!(key.key in result)) {
      result[key.key] = key.defaultValue ?? key.key;
    }
  }

  // Sort keys
  return Object.fromEntries(Object.entries(result).sort(([a], [b]) => a.localeCompare(b)));
}

/**
 * Build nested JSON structure from dot notation keys
 */
function buildNestedJSON(
  keys: ExtractedKey[],
  existing: Record<string, unknown>
): Record<string, unknown> {
  const result: Record<string, unknown> = { ...existing };

  for (const key of keys) {
    const parts = key.key.split('.');
    let current: Record<string, unknown> = result;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!(part in current) || typeof current[part] !== 'object') {
        current[part] = {};
      }
      current = current[part] as Record<string, unknown>;
    }

    const lastPart = parts[parts.length - 1];
    if (!(lastPart in current)) {
      current[lastPart] = key.defaultValue ?? key.key;
    }
  }

  return sortObjectRecursive(result);
}

/**
 * Sort object keys recursively
 */
function sortObjectRecursive(obj: Record<string, unknown>): Record<string, unknown> {
  const sorted: Record<string, unknown> = {};

  for (const key of Object.keys(obj).sort()) {
    const value = obj[key];
    if (value && typeof value === 'object' && !Array.isArray(value)) {
      sorted[key] = sortObjectRecursive(value as Record<string, unknown>);
    } else {
      sorted[key] = value;
    }
  }

  return sorted;
}

/**
 * Generate POT (Portable Object Template) file
 */
async function generatePOT(keys: ExtractedKey[], outputDir: string): Promise<void> {
  const lines: string[] = [
    '# AIVO Translation Template',
    '# Generated by @aivo/i18n-cli',
    `# Generated: ${new Date().toISOString()}`,
    '',
    'msgid ""',
    'msgstr ""',
    '"Content-Type: text/plain; charset=UTF-8\\n"',
    '"Content-Transfer-Encoding: 8bit\\n"',
    '',
  ];

  // Group by namespace
  const byNamespace = new Map<string, ExtractedKey[]>();
  for (const key of keys) {
    const ns = key.namespace ?? 'common';
    const existing = byNamespace.get(ns) ?? [];
    existing.push(key);
    byNamespace.set(ns, existing);
  }

  for (const [namespace, nsKeys] of byNamespace) {
    lines.push(`# Namespace: ${namespace}`);
    lines.push('');

    for (const key of nsKeys) {
      // Reference comment
      lines.push(`#: ${key.filePath}:${key.line}`);

      // Context (namespace)
      if (namespace !== 'common') {
        lines.push(`msgctxt "${namespace}"`);
      }

      // Message ID
      lines.push(`msgid "${escapePoString(key.key)}"`);

      // Plural forms
      if (key.count) {
        lines.push(`msgid_plural "${escapePoString(key.key)}_plural"`);
        lines.push('msgstr[0] ""');
        lines.push('msgstr[1] ""');
      } else {
        lines.push('msgstr ""');
      }

      lines.push('');
    }
  }

  const content = lines.join('\n');
  await fs.writeFile(path.join(outputDir, 'messages.pot'), content);
}

/**
 * Escape string for PO format
 */
function escapePoString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\t/g, '\\t');
}

/**
 * Generate ARB (Application Resource Bundle) files for Flutter
 */
async function generateARB(
  keys: ExtractedKey[],
  outputDir: string,
  locales: string[]
): Promise<void> {
  for (const locale of locales) {
    const arb: Record<string, unknown> = {
      '@@locale': locale,
      '@@last_modified': new Date().toISOString(),
    };

    for (const key of keys) {
      const arbKey = key.key.replace(/\./g, '_');

      if (!(arbKey in arb)) {
        arb[arbKey] = key.defaultValue ?? key.key;

        // Add metadata
        arb[`@${arbKey}`] = {
          description: key.context ?? `Translation key: ${key.key}`,
          type: 'text',
          placeholders: {},
        };

        // Add placeholders if key contains interpolation
        const placeholderMatch = key.key.match(/\{(\w+)\}/g);
        if (placeholderMatch) {
          const placeholders: Record<string, unknown> = {};
          for (const match of placeholderMatch) {
            const name = match.slice(1, -1);
            placeholders[name] = { type: 'String' };
          }
          (arb[`@${arbKey}`] as Record<string, unknown>).placeholders = placeholders;
        }
      }
    }

    const filePath = path.join(outputDir, `app_${locale}.arb`);
    await fs.writeFile(filePath, JSON.stringify(arb, null, 2) + '\n');
  }
}
