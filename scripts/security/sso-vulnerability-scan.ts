#!/usr/bin/env ts-node
/**
 * SSO Vulnerability Scanner
 *
 * Automated security scanner for SSO implementations.
 * Scans for common vulnerabilities and misconfigurations.
 *
 * Usage:
 *   pnpm tsx scripts/security/sso-vulnerability-scan.ts
 *   pnpm tsx scripts/security/sso-vulnerability-scan.ts --fix (to generate fix suggestions)
 *
 * @module security/sso-vulnerability-scan
 */

import { readFileSync, existsSync, readdirSync, writeFileSync } from 'fs';
import { join, relative } from 'path';

// =============================================================================
// Types
// =============================================================================

interface VulnerabilityFinding {
  id: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
  category: string;
  title: string;
  description: string;
  file: string;
  line?: number;
  codeSnippet?: string;
  remediation: string;
  cweId?: string;
  owaspCategory?: string;
}

interface ScanResult {
  timestamp: string;
  totalFiles: number;
  filesScanned: number;
  findings: VulnerabilityFinding[];
  summary: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
}

interface ScanRule {
  id: string;
  severity: VulnerabilityFinding['severity'];
  category: string;
  title: string;
  description: string;
  pattern: RegExp;
  remediation: string;
  cweId?: string;
  owaspCategory?: string;
  filePatterns?: RegExp[];
  excludePatterns?: RegExp[];
}

// =============================================================================
// Configuration
// =============================================================================

const ROOT_DIR = join(__dirname, '..', '..');
const SERVICES_DIR = join(ROOT_DIR, 'services');
const LIBS_DIR = join(ROOT_DIR, 'libs');

const FILE_PATTERNS = [
  /\.ts$/,
  /\.tsx$/,
  /\.js$/,
  /\.jsx$/,
];

const EXCLUDE_DIRS = [
  'node_modules',
  'dist',
  'build',
  '.next',
  'coverage',
  '__tests__',
  '__mocks__',
  '.turbo',
];

const EXCLUDE_FILES = [
  /\.test\./,
  /\.spec\./,
  /\.d\.ts$/,
  /\.config\./,
];

// =============================================================================
// Security Scan Rules
// =============================================================================

const SCAN_RULES: ScanRule[] = [
  // Critical: Hardcoded Secrets
  {
    id: 'SSO-001',
    severity: 'CRITICAL',
    category: 'Secrets Management',
    title: 'Hardcoded encryption key or secret',
    description:
      'Hardcoded secrets found in source code. These can be extracted from version control and used to compromise the system.',
    pattern:
      /(fallback[-_]?key|fallback[-_]?secret|default[-_]?secret|hardcoded[-_]?key)['":\s]*[=:]\s*['"][^'"]{8,}['"]/gi,
    remediation:
      'Remove hardcoded secrets. Use environment variables and fail startup if not configured.',
    cweId: 'CWE-798',
    owaspCategory: 'A02:2021-Cryptographic Failures',
  },
  {
    id: 'SSO-002',
    severity: 'CRITICAL',
    category: 'Secrets Management',
    title: 'JWT secret in code',
    description:
      'JWT signing secrets should never be hardcoded. Found potential hardcoded JWT secret.',
    pattern: /(jwt[-_]?secret|signing[-_]?key|private[-_]?key)['":\s]*[=:]\s*['"][A-Za-z0-9+/=]{16,}['"]/gi,
    remediation:
      'Store JWT secrets in secure secret management (Vault, AWS Secrets Manager, etc.)',
    cweId: 'CWE-798',
    owaspCategory: 'A02:2021-Cryptographic Failures',
  },

  // Critical: Signature Validation
  {
    id: 'SSO-003',
    severity: 'CRITICAL',
    category: 'SAML Security',
    title: 'Optional SAML signature validation',
    description:
      'SAML signature validation is optional or can be bypassed. Attackers can forge SAML assertions.',
    pattern: /if\s*\(\s*!?\s*(signature|signed|hasSignature)\s*\)\s*{\s*return\s+true/gi,
    remediation:
      'SAML signatures must always be required and validated. Remove any code paths that skip validation.',
    cweId: 'CWE-347',
    owaspCategory: 'A07:2021-Identification and Authentication Failures',
    filePatterns: [/saml/i],
  },
  {
    id: 'SSO-004',
    severity: 'CRITICAL',
    category: 'SAML Security',
    title: 'Regex-based XML parsing',
    description:
      'Using regex to parse XML is insecure and vulnerable to signature wrapping attacks.',
    pattern: /\.(match|exec|test)\s*\(\s*[/`'"]\s*<\s*(Signature|SignedInfo|Assertion|Response)/gi,
    remediation:
      'Use a proper XML parser with canonicalization support (e.g., xml-crypto, xmldom).',
    cweId: 'CWE-91',
    owaspCategory: 'A03:2021-Injection',
  },

  // Critical: Open Redirect
  {
    id: 'SSO-005',
    severity: 'CRITICAL',
    category: 'Redirect Validation',
    title: 'Missing redirect URI validation',
    description:
      'Redirect URI is not validated against a whitelist, allowing open redirect attacks.',
    pattern:
      /redirect[_-]?uri|return[_-]?url|callback[_-]?url|next[_-]?url/gi,
    remediation:
      'Validate redirect URIs against a strict whitelist of allowed domains.',
    cweId: 'CWE-601',
    owaspCategory: 'A01:2021-Broken Access Control',
  },

  // High: PKCE
  {
    id: 'SSO-006',
    severity: 'HIGH',
    category: 'OAuth Security',
    title: 'Missing PKCE implementation',
    description:
      'Authorization code flow without PKCE is vulnerable to code interception attacks.',
    pattern: /authorization[_-]?code|code[_-]?verifier|code[_-]?challenge/gi,
    remediation:
      'Implement PKCE with S256 code challenge method for all OAuth flows.',
    cweId: 'CWE-384',
    owaspCategory: 'A07:2021-Identification and Authentication Failures',
  },

  // High: Token Exposure
  {
    id: 'SSO-007',
    severity: 'HIGH',
    category: 'Token Security',
    title: 'Tokens in URL parameters',
    description:
      'Access or refresh tokens passed in URL query strings can leak via Referer headers, logs, and browser history.',
    pattern:
      /\?\s*(access[_-]?token|refresh[_-]?token|token)\s*=|\+\s*['"`]\s*(access[_-]?token|refresh[_-]?token|token)\s*=\s*['"`]/gi,
    remediation:
      'Pass tokens in POST body or secure cookies, never in URL parameters.',
    cweId: 'CWE-598',
    owaspCategory: 'A04:2021-Insecure Design',
  },

  // High: Algorithm Confusion
  {
    id: 'SSO-008',
    severity: 'HIGH',
    category: 'JWT Security',
    title: 'Unsafe JWT algorithm configuration',
    description:
      'JWT algorithm not explicitly set or allows "none" algorithm, enabling signature bypass.',
    pattern: /algorithms?\s*[=:]\s*\[\s*['"]?(none|HS256|any)['"]?\s*\]/gi,
    remediation:
      'Explicitly require RS256 or ES256. Never allow "none" or HS256 with public keys.',
    cweId: 'CWE-327',
    owaspCategory: 'A02:2021-Cryptographic Failures',
  },

  // Medium: Session Security
  {
    id: 'SSO-009',
    severity: 'MEDIUM',
    category: 'Session Security',
    title: 'Missing session regeneration',
    description:
      'Session ID not regenerated after authentication, enabling session fixation attacks.',
    pattern: /regenerate[_-]?session|session\.regenerate/gi,
    remediation:
      'Regenerate session ID immediately after successful authentication.',
    cweId: 'CWE-384',
    owaspCategory: 'A07:2021-Identification and Authentication Failures',
  },

  // Medium: Cookie Security
  {
    id: 'SSO-010',
    severity: 'MEDIUM',
    category: 'Cookie Security',
    title: 'Missing cookie security attributes',
    description:
      'Cookies missing HttpOnly, Secure, or SameSite attributes.',
    pattern:
      /set[-_]?cookie|cookie\s*[=:]\s*{[^}]*(?!httpOnly|secure|sameSite)/gi,
    remediation:
      'Set HttpOnly, Secure, and SameSite=Strict on all authentication cookies.',
    cweId: 'CWE-614',
    owaspCategory: 'A05:2021-Security Misconfiguration',
  },

  // Medium: CSRF
  {
    id: 'SSO-011',
    severity: 'MEDIUM',
    category: 'CSRF Protection',
    title: 'Missing CSRF token validation',
    description:
      'State-changing operations without CSRF token validation.',
    pattern: /csrf[_-]?token|anti[_-]?csrf|xsrf[_-]?token/gi,
    remediation:
      'Implement CSRF tokens or ensure SameSite=Strict on session cookies.',
    cweId: 'CWE-352',
    owaspCategory: 'A01:2021-Broken Access Control',
  },

  // Medium: Error Handling
  {
    id: 'SSO-012',
    severity: 'MEDIUM',
    category: 'Error Handling',
    title: 'Verbose error messages',
    description:
      'Detailed error messages may leak sensitive information about authentication mechanisms.',
    pattern: /console\.(log|error|warn)\s*\([^)]*(?:password|secret|token|key)/gi,
    remediation:
      'Log errors without sensitive data. Use generic user-facing messages.',
    cweId: 'CWE-209',
    owaspCategory: 'A09:2021-Security Logging and Monitoring Failures',
  },

  // Low: HTTP in Development
  {
    id: 'SSO-013',
    severity: 'LOW',
    category: 'Transport Security',
    title: 'HTTP allowed in non-production',
    description:
      'HTTP (non-HTTPS) may be allowed in development, risking credential theft.',
    pattern: /http:\/\/localhost|secure:\s*(false|process\.env)/gi,
    remediation:
      'Use HTTPS even in development with self-signed certificates.',
    cweId: 'CWE-319',
    owaspCategory: 'A02:2021-Cryptographic Failures',
  },

  // Info: Deprecated Methods
  {
    id: 'SSO-014',
    severity: 'INFO',
    category: 'Deprecated Features',
    title: 'Deprecated cryptographic method',
    description:
      'Using deprecated or weak cryptographic methods.',
    pattern: /createCipher\s*\(|MD5|SHA1(?!-)|DES|RC4/gi,
    remediation:
      'Use modern algorithms: AES-256-GCM, SHA-256, RSA-2048+.',
    cweId: 'CWE-327',
    owaspCategory: 'A02:2021-Cryptographic Failures',
  },

  // Additional OIDC-specific rules
  {
    id: 'SSO-015',
    severity: 'HIGH',
    category: 'OIDC Security',
    title: 'Missing nonce validation',
    description:
      'OIDC nonce not validated, enabling ID token replay attacks.',
    pattern: /nonce\s*[=:]\s*(?:undefined|null|['"]?['"]?)/gi,
    remediation:
      'Generate cryptographically random nonce and validate in ID token.',
    cweId: 'CWE-294',
    owaspCategory: 'A07:2021-Identification and Authentication Failures',
    filePatterns: [/oidc|oauth/i],
  },

  // LTI-specific rules
  {
    id: 'SSO-016',
    severity: 'HIGH',
    category: 'LTI Security',
    title: 'Missing deployment ID validation',
    description:
      'LTI 1.3 deployment_id not validated against registered deployments.',
    pattern: /deployment[_-]?id|lti[_-]?deployment/gi,
    remediation:
      'Validate deployment_id against registered platform deployments.',
    cweId: 'CWE-862',
    owaspCategory: 'A01:2021-Broken Access Control',
    filePatterns: [/lti/i],
  },
];

// =============================================================================
// Utility Functions
// =============================================================================

function getAllFiles(dir: string, files: string[] = []): string[] {
  if (!existsSync(dir)) return files;

  const entries = readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = join(dir, entry.name);

    if (entry.isDirectory()) {
      if (!EXCLUDE_DIRS.includes(entry.name)) {
        getAllFiles(fullPath, files);
      }
    } else {
      const matchesPattern = FILE_PATTERNS.some((p) => p.test(entry.name));
      const isExcluded = EXCLUDE_FILES.some((p) => p.test(entry.name));

      if (matchesPattern && !isExcluded) {
        files.push(fullPath);
      }
    }
  }

  return files;
}

function getLineNumber(content: string, index: number): number {
  return content.substring(0, index).split('\n').length;
}

function getCodeSnippet(content: string, line: number, context = 2): string {
  const lines = content.split('\n');
  const start = Math.max(0, line - context - 1);
  const end = Math.min(lines.length, line + context);

  return lines
    .slice(start, end)
    .map((l, i) => {
      const lineNum = start + i + 1;
      const marker = lineNum === line ? '> ' : '  ';
      return `${marker}${lineNum.toString().padStart(4, ' ')} | ${l}`;
    })
    .join('\n');
}

function shouldScanFile(file: string, rule: ScanRule): boolean {
  if (rule.excludePatterns?.some((p) => p.test(file))) {
    return false;
  }
  if (rule.filePatterns && !rule.filePatterns.some((p) => p.test(file))) {
    return false;
  }
  return true;
}

// =============================================================================
// Scanner Implementation
// =============================================================================

class SSOVulnerabilityScanner {
  private findings: VulnerabilityFinding[] = [];
  private filesScanned = 0;
  private totalFiles = 0;

  async scan(): Promise<ScanResult> {
    console.log('üîç Starting SSO Vulnerability Scan...\n');

    // Collect files to scan
    const serviceFiles = getAllFiles(SERVICES_DIR);
    const libFiles = getAllFiles(LIBS_DIR);
    const allFiles = [...serviceFiles, ...libFiles];
    this.totalFiles = allFiles.length;

    console.log(`üìÅ Found ${this.totalFiles} files to scan\n`);

    // Scan each file
    for (const file of allFiles) {
      this.scanFile(file);
    }

    // Generate result
    const result: ScanResult = {
      timestamp: new Date().toISOString(),
      totalFiles: this.totalFiles,
      filesScanned: this.filesScanned,
      findings: this.findings,
      summary: {
        critical: this.findings.filter((f) => f.severity === 'CRITICAL').length,
        high: this.findings.filter((f) => f.severity === 'HIGH').length,
        medium: this.findings.filter((f) => f.severity === 'MEDIUM').length,
        low: this.findings.filter((f) => f.severity === 'LOW').length,
        info: this.findings.filter((f) => f.severity === 'INFO').length,
      },
    };

    return result;
  }

  private scanFile(filePath: string): void {
    try {
      const content = readFileSync(filePath, 'utf-8');
      const relPath = relative(ROOT_DIR, filePath);
      this.filesScanned++;

      for (const rule of SCAN_RULES) {
        if (!shouldScanFile(filePath, rule)) continue;

        // Reset regex lastIndex for global patterns
        rule.pattern.lastIndex = 0;
        let match;

        while ((match = rule.pattern.exec(content)) !== null) {
          const line = getLineNumber(content, match.index);
          const snippet = getCodeSnippet(content, line);

          // Check if this is a comment or string (basic heuristic)
          const lineContent = content.split('\n')[line - 1] || '';
          if (
            lineContent.trim().startsWith('//') ||
            lineContent.trim().startsWith('*')
          ) {
            continue;
          }

          this.findings.push({
            id: `${rule.id}-${this.findings.length + 1}`,
            severity: rule.severity,
            category: rule.category,
            title: rule.title,
            description: rule.description,
            file: relPath,
            line,
            codeSnippet: snippet,
            remediation: rule.remediation,
            cweId: rule.cweId,
            owaspCategory: rule.owaspCategory,
          });

          // Prevent infinite loops for non-global patterns
          if (!rule.pattern.global) break;
        }
      }
    } catch (error) {
      console.error(`‚ö†Ô∏è Error scanning ${filePath}:`, error);
    }
  }
}

// =============================================================================
// Report Generation
// =============================================================================

function generateConsoleReport(result: ScanResult): void {
  console.log('\n' + '='.repeat(80));
  console.log('üìä SCAN RESULTS');
  console.log('='.repeat(80));

  console.log(`\nüìÖ Timestamp: ${result.timestamp}`);
  console.log(`üìÅ Files Scanned: ${result.filesScanned}/${result.totalFiles}`);
  console.log(`üîç Total Findings: ${result.findings.length}\n`);

  // Summary by severity
  console.log('üìà Summary by Severity:');
  console.log(`   üî¥ CRITICAL: ${result.summary.critical}`);
  console.log(`   üü† HIGH:     ${result.summary.high}`);
  console.log(`   üü° MEDIUM:   ${result.summary.medium}`);
  console.log(`   üü¢ LOW:      ${result.summary.low}`);
  console.log(`   üîµ INFO:     ${result.summary.info}`);

  // Detailed findings
  if (result.findings.length > 0) {
    console.log('\n' + '-'.repeat(80));
    console.log('üìã DETAILED FINDINGS');
    console.log('-'.repeat(80));

    const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];

    for (const severity of severityOrder) {
      const findings = result.findings.filter((f) => f.severity === severity);
      if (findings.length === 0) continue;

      const icon =
        severity === 'CRITICAL'
          ? 'üî¥'
          : severity === 'HIGH'
            ? 'üü†'
            : severity === 'MEDIUM'
              ? 'üü°'
              : severity === 'LOW'
                ? 'üü¢'
                : 'üîµ';

      console.log(`\n${icon} ${severity} (${findings.length} findings)`);
      console.log('-'.repeat(40));

      for (const finding of findings) {
        console.log(`\n  [${finding.id}] ${finding.title}`);
        console.log(`  üìÅ ${finding.file}:${finding.line || 'N/A'}`);
        console.log(`  üìù ${finding.description}`);
        if (finding.cweId) {
          console.log(`  üîó ${finding.cweId} | ${finding.owaspCategory}`);
        }
        console.log(`  ‚úÖ Fix: ${finding.remediation}`);
        if (finding.codeSnippet) {
          console.log('\n  Code:');
          console.log(
            finding.codeSnippet
              .split('\n')
              .map((l) => `    ${l}`)
              .join('\n')
          );
        }
      }
    }
  }

  console.log('\n' + '='.repeat(80));

  // Exit code based on critical/high findings
  if (result.summary.critical > 0) {
    console.log('\n‚ùå SCAN FAILED: Critical vulnerabilities found!\n');
    process.exitCode = 2;
  } else if (result.summary.high > 0) {
    console.log('\n‚ö†Ô∏è SCAN WARNING: High severity issues found.\n');
    process.exitCode = 1;
  } else {
    console.log('\n‚úÖ SCAN PASSED: No critical or high severity issues.\n');
    process.exitCode = 0;
  }
}

function generateJsonReport(result: ScanResult, outputPath: string): void {
  writeFileSync(outputPath, JSON.stringify(result, null, 2));
  console.log(`üìÑ JSON report written to: ${outputPath}`);
}

function generateMarkdownReport(result: ScanResult, outputPath: string): void {
  let md = `# SSO Security Scan Report\n\n`;
  md += `**Scan Date:** ${result.timestamp}\n`;
  md += `**Files Scanned:** ${result.filesScanned}/${result.totalFiles}\n`;
  md += `**Total Findings:** ${result.findings.length}\n\n`;

  md += `## Summary\n\n`;
  md += `| Severity | Count |\n`;
  md += `|----------|-------|\n`;
  md += `| üî¥ Critical | ${result.summary.critical} |\n`;
  md += `| üü† High | ${result.summary.high} |\n`;
  md += `| üü° Medium | ${result.summary.medium} |\n`;
  md += `| üü¢ Low | ${result.summary.low} |\n`;
  md += `| üîµ Info | ${result.summary.info} |\n\n`;

  if (result.findings.length > 0) {
    md += `## Findings\n\n`;

    const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];

    for (const severity of severityOrder) {
      const findings = result.findings.filter((f) => f.severity === severity);
      if (findings.length === 0) continue;

      md += `### ${severity}\n\n`;

      for (const finding of findings) {
        md += `#### [${finding.id}] ${finding.title}\n\n`;
        md += `- **File:** \`${finding.file}\`${finding.line ? `:${finding.line}` : ''}\n`;
        md += `- **Category:** ${finding.category}\n`;
        if (finding.cweId) {
          md += `- **CWE:** ${finding.cweId}\n`;
          md += `- **OWASP:** ${finding.owaspCategory}\n`;
        }
        md += `\n**Description:** ${finding.description}\n\n`;
        md += `**Remediation:** ${finding.remediation}\n\n`;

        if (finding.codeSnippet) {
          md += `**Code:**\n\`\`\`typescript\n${finding.codeSnippet}\n\`\`\`\n\n`;
        }

        md += `---\n\n`;
      }
    }
  }

  writeFileSync(outputPath, md);
  console.log(`üìÑ Markdown report written to: ${outputPath}`);
}

// =============================================================================
// Main Entry Point
// =============================================================================

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const showHelp = args.includes('--help') || args.includes('-h');
  const outputJson = args.find((a) => a.startsWith('--json='))?.split('=')[1];
  const outputMd = args.find((a) => a.startsWith('--md='))?.split('=')[1];

  if (showHelp) {
    console.log(`
SSO Vulnerability Scanner

Usage:
  pnpm tsx scripts/security/sso-vulnerability-scan.ts [options]

Options:
  --help, -h          Show this help message
  --json=<path>       Write JSON report to file
  --md=<path>         Write Markdown report to file

Examples:
  pnpm tsx scripts/security/sso-vulnerability-scan.ts
  pnpm tsx scripts/security/sso-vulnerability-scan.ts --json=report.json
  pnpm tsx scripts/security/sso-vulnerability-scan.ts --md=docs/security/scan-report.md
    `);
    return;
  }

  const scanner = new SSOVulnerabilityScanner();
  const result = await scanner.scan();

  generateConsoleReport(result);

  if (outputJson) {
    generateJsonReport(result, outputJson);
  }

  if (outputMd) {
    generateMarkdownReport(result, outputMd);
  }
}

main().catch((error: unknown) => {
  console.error('‚ùå Scanner error:', error);
  process.exit(1);
});
