// ══════════════════════════════════════════════════════════════════════════════
// BILLING SERVICE - PRISMA SCHEMA
// ══════════════════════════════════════════════════════════════════════════════
// 
// This schema defines the billing & subscription data model for the Aivo platform.
// It supports:
//   - Parent (consumer) subscriptions with base + add-on modules
//   - District contracts with seat-based licensing
//   - Payment provider abstraction (Stripe, manual invoice, etc.)
//   - Trials, proration, and invoice management
//
// ══════════════════════════════════════════════════════════════════════════════

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ══════════════════════════════════════════════════════════════════════════════
// ENUMS
// ══════════════════════════════════════════════════════════════════════════════

/// Type of billing account - determines business rules and UI flows
enum BillingAccountType {
  PARENT_CONSUMER   // Individual parent paying for their children
  DISTRICT          // School district with seat-based licensing
  PLATFORM_INTERNAL // Internal/free accounts (e.g., demo, testing)
}

/// Current status of a subscription
enum SubscriptionStatus {
  IN_TRIAL    // Active trial period, no charges yet
  ACTIVE      // Paid and in good standing
  PAST_DUE    // Payment failed, grace period
  CANCELED    // User canceled, may have access until period end
  EXPIRED     // Subscription ended, no access
}

/// Type of plan - determines pricing logic and features
enum PlanType {
  PARENT_BASE     // Core ELA + Math for parent subscribers
  PARENT_ADDON    // Add-on modules (SEL, Speech, Science, etc.)
  DISTRICT_BASE   // Base district licensing
  DISTRICT_ADDON  // District add-on modules
}

/// Billing frequency
enum BillingPeriod {
  MONTHLY
  YEARLY
}

/// Payment provider for processing payments
enum PaymentProvider {
  STRIPE          // Stripe payment processor
  MANUAL_INVOICE  // Manual invoicing (for districts)
  TEST_FAKE       // Test/fake provider for development
}

/// Billing period for contract pricing and line items
enum ContractBillingPeriod {
  ANNUAL      // Billed yearly
  MULTI_YEAR  // Upfront multi-year (e.g., 3-year deal)
  ONE_TIME    // One-time charge (setup fees, etc.)
}

/// Contract status lifecycle
enum ContractStatus {
  DRAFT       // Being negotiated, not yet active
  PENDING     // Signed but awaiting start date
  ACTIVE      // Currently in effect
  SUSPENDED   // Temporarily suspended (e.g., payment issues)
  EXPIRED     // Past end date, naturally ended
  CANCELLED   // Terminated before end date
  RENEWED     // Replaced by a new contract
}

/// Payment type for contracts
enum ContractPaymentType {
  INVOICE     // Net terms invoice (typical for districts)
  CARD        // Credit card payment
  HYBRID      // Mix of invoice and card
  PO          // Purchase order based
}

/// Invoice status
enum InvoiceStatus {
  DRAFT         // Being prepared, not yet finalized
  OPEN          // Finalized and awaiting payment
  PAID          // Successfully paid
  VOID          // Canceled/voided
  UNCOLLECTIBLE // Payment failed, written off
}

// ══════════════════════════════════════════════════════════════════════════════
// BILLING ACCOUNTS
// ══════════════════════════════════════════════════════════════════════════════
// 
// A billing account represents a paying entity - either a parent or a district.
// It links to a tenant and optionally to an owner user.
//

model BillingAccount {
  id                    String              @id @default(uuid()) @db.Uuid
  
  /// Reference to the tenant this billing account belongs to
  tenantId              String              @db.Uuid
  
  /// Type of billing account
  accountType           BillingAccountType
  
  /// Owner user (for parent accounts). Null for district/internal accounts.
  ownerUserId           String?             @db.Uuid
  
  /// Display name for the account (e.g., "Smith Family" or "North Valley District")
  displayName           String
  
  /// Payment provider used for this account
  provider              PaymentProvider     @default(STRIPE)
  
  /// External customer ID in the payment provider (e.g., Stripe customer ID)
  providerCustomerId    String?
  
  /// Default currency for this account
  defaultCurrency       String              @default("USD") @db.VarChar(3)
  
  /// Email for billing notifications
  billingEmail          String?
  
  /// Additional metadata (e.g., tax exemption info, contract terms)
  metadataJson          Json?
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Relations
  subscriptions         Subscription[]
  billingInstruments    BillingInstrument[]
  invoices              Invoice[]
  districtProfile       DistrictBillingProfile?
  
  @@index([tenantId, accountType])
  @@index([providerCustomerId])
  @@map("billing_accounts")
}

// ══════════════════════════════════════════════════════════════════════════════
// PLANS
// ══════════════════════════════════════════════════════════════════════════════
//
// Plans define what's available for purchase. Plans are reusable templates
// that subscriptions reference. They include pricing and feature definitions.
//

model Plan {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Unique SKU identifier (e.g., "PARENT_BASE", "ADDON_SEL", "DISTRICT_BASE_1Y")
  sku             String        @unique
  
  /// Type of plan
  planType        PlanType
  
  /// Human-readable name
  name            String
  
  /// Description for display
  description     String?
  
  /// Price in cents per unit per billing period
  unitPriceCents  Int
  
  /// Billing frequency
  billingPeriod   BillingPeriod @default(MONTHLY)
  
  /// Whether this plan is currently available for new subscriptions
  isActive        Boolean       @default(true)
  
  /// Trial duration in days (0 = no trial)
  trialDays       Int           @default(0)
  
  /// Metadata: features, limits, modules included, etc.
  /// Example: { "modules": ["ELA", "MATH"], "maxLearners": 5 }
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  subscriptions       Subscription[]
  subscriptionItems   SubscriptionItem[]
  
  @@index([planType, isActive])
  @@map("plans")
}

// ══════════════════════════════════════════════════════════════════════════════
// SUBSCRIPTIONS
// ══════════════════════════════════════════════════════════════════════════════
//
// A subscription represents an active (or past) agreement between a billing
// account and a plan. Tracks status, billing periods, and trial information.
//

model Subscription {
  id                      String              @id @default(uuid()) @db.Uuid
  
  /// The billing account that owns this subscription
  billingAccountId        String              @db.Uuid
  
  /// The plan this subscription is based on
  planId                  String              @db.Uuid
  
  /// Current subscription status
  status                  SubscriptionStatus  @default(IN_TRIAL)
  
  /// Quantity: # of children (parent) or seats/learners (district)
  quantity                Int                 @default(1)
  
  /// Trial period start (null if no trial)
  trialStartAt            DateTime?           @db.Timestamptz
  
  /// Trial period end (null if no trial)
  trialEndAt              DateTime?           @db.Timestamptz
  
  /// Current billing period start
  currentPeriodStart      DateTime            @db.Timestamptz
  
  /// Current billing period end
  currentPeriodEnd        DateTime            @db.Timestamptz
  
  /// Whether subscription will be canceled at period end
  cancelAtPeriodEnd       Boolean             @default(false)
  
  /// Date when subscription was canceled (null if not canceled)
  canceledAt              DateTime?           @db.Timestamptz
  
  /// Date when subscription ended/will end
  endedAt                 DateTime?           @db.Timestamptz
  
  /// External subscription ID in payment provider
  providerSubscriptionId  String?
  
  /// Metadata: specific modules unlocked, contract terms, etc.
  /// Example: { "modules": ["ELA", "MATH", "SEL"], "contractNumber": "DST-2024-001" }
  metadataJson            Json?
  
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt
  
  // Relations
  billingAccount          BillingAccount      @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  plan                    Plan                @relation(fields: [planId], references: [id])
  subscriptionItems       SubscriptionItem[]
  invoiceLineItems        InvoiceLineItem[]
  
  @@index([billingAccountId, status])
  @@index([providerSubscriptionId])
  @@index([status, currentPeriodEnd])
  @@map("subscriptions")
}

// ══════════════════════════════════════════════════════════════════════════════
// SUBSCRIPTION ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Line items within a subscription for itemized billing.
// Useful when a single subscription includes multiple plans (e.g., base + add-ons)
// or when tracking per-learner allocation.
//

model SubscriptionItem {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Parent subscription
  subscriptionId  String        @db.Uuid
  
  /// The plan/product for this line item
  planId          String        @db.Uuid
  
  /// SKU reference (denormalized for query convenience)
  sku             String
  
  /// Quantity of this item
  quantity        Int           @default(1)
  
  /// Optional: Specific learner this item is allocated to
  learnerId       String?       @db.Uuid
  
  /// Metadata: module-specific settings, etc.
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  plan            Plan          @relation(fields: [planId], references: [id])
  
  @@index([subscriptionId])
  @@index([learnerId])
  @@map("subscription_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// BILLING INSTRUMENTS (Payment Methods)
// ══════════════════════════════════════════════════════════════════════════════
//
// Stored payment methods. Only tokenized references are stored - never raw card data.
//

model BillingInstrument {
  id                        String          @id @default(uuid()) @db.Uuid
  
  /// The billing account this payment method belongs to
  billingAccountId          String          @db.Uuid
  
  /// External payment method ID in payment provider (e.g., Stripe pm_xxx)
  providerPaymentMethodId   String
  
  /// Card brand (e.g., "visa", "mastercard", "amex")
  brand                     String?
  
  /// Last 4 digits of card number
  last4                     String?         @db.VarChar(4)
  
  /// Expiry month (1-12)
  expiryMonth               Int?            @db.SmallInt
  
  /// Expiry year (e.g., 2025)
  expiryYear                Int?            @db.SmallInt
  
  /// Whether this is the default payment method for the account
  isDefault                 Boolean         @default(false)
  
  /// Type of instrument (card, bank_account, etc.)
  instrumentType            String          @default("card")
  
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt
  
  // Relations
  billingAccount            BillingAccount  @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  
  @@index([billingAccountId])
  @@index([providerPaymentMethodId])
  @@map("billing_instruments")
}

// ══════════════════════════════════════════════════════════════════════════════
// INVOICES
// ══════════════════════════════════════════════════════════════════════════════
//
// Invoices track charges and payments. They can be generated automatically
// from subscriptions or manually for districts.
//

model Invoice {
  id                  String          @id @default(uuid()) @db.Uuid
  
  /// Billing account this invoice belongs to
  billingAccountId    String          @db.Uuid
  
  /// External invoice ID in payment provider
  providerInvoiceId   String?
  
  /// Human-readable invoice number (e.g., "INV-2024-00001")
  invoiceNumber       String?         @unique
  
  /// Total amount due in cents
  amountDueCents      Int
  
  /// Amount already paid in cents
  amountPaidCents     Int             @default(0)
  
  /// Currency code
  currency            String          @default("USD") @db.VarChar(3)
  
  /// Invoice status
  status              InvoiceStatus   @default(DRAFT)
  
  /// Billing period start this invoice covers
  periodStart         DateTime        @db.Timestamptz
  
  /// Billing period end this invoice covers
  periodEnd           DateTime        @db.Timestamptz
  
  /// When the invoice was finalized and sent
  issuedAt            DateTime?       @db.Timestamptz
  
  /// Payment due date
  dueAt               DateTime?       @db.Timestamptz
  
  /// When payment was received
  paidAt              DateTime?       @db.Timestamptz
  
  /// PDF URL or path
  pdfUrl              String?
  
  /// Metadata: proration info, adjustments, notes, etc.
  metadataJson        Json?
  
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  
  // Relations
  billingAccount      BillingAccount  @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  lineItems           InvoiceLineItem[]
  
  @@index([billingAccountId, issuedAt(sort: Desc)])
  @@index([status])
  @@index([providerInvoiceId])
  @@map("invoices")
}

// ══════════════════════════════════════════════════════════════════════════════
// INVOICE LINE ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual line items on an invoice. Can represent subscription charges,
// prorations, one-time charges, credits, etc.
//

model InvoiceLineItem {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Parent invoice
  invoiceId       String        @db.Uuid
  
  /// Optional: linked subscription for recurring charges
  subscriptionId  String?       @db.Uuid
  
  /// Description of the charge
  description     String
  
  /// Unit price in cents
  unitPriceCents  Int
  
  /// Quantity
  quantity        Int           @default(1)
  
  /// Total amount in cents (unitPriceCents * quantity, or custom for prorations)
  amountCents     Int
  
  /// Type of line item
  lineItemType    String        @default("subscription") // subscription, proration, credit, one_time
  
  /// Metadata: proration details, period adjustments, etc.
  /// Example: { "prorationFactor": 0.5, "originalPeriodStart": "...", "reason": "mid-cycle upgrade" }
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  
  // Relations
  invoice         Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  subscription    Subscription? @relation(fields: [subscriptionId], references: [id])
  
  @@index([invoiceId])
  @@index([subscriptionId])
  @@map("invoice_line_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// USAGE RECORDS (for metered billing - future)
// ══════════════════════════════════════════════════════════════════════════════
//
// Tracks usage for metered billing scenarios (e.g., API calls, extra learners).
// Included for future extensibility but not required for initial implementation.
//

model UsageRecord {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Subscription this usage is for
  subscriptionId  String        @db.Uuid
  
  /// Metric being tracked (e.g., "learner_count", "api_calls", "storage_gb")
  metric          String
  
  /// Quantity of usage
  quantity        Int
  
  /// Timestamp of the usage
  timestamp       DateTime      @db.Timestamptz
  
  /// Whether this has been invoiced
  invoiced        Boolean       @default(false)
  
  /// Metadata: additional context
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  
  @@index([subscriptionId, metric, timestamp])
  @@index([invoiced])
  @@map("usage_records")
}

// ══════════════════════════════════════════════════════════════════════════════
// PAYMENT EVENTS (Audit Log)
// ══════════════════════════════════════════════════════════════════════════════
//
// Tracks all payment-related events from external providers (Stripe webhooks,
// etc.) for auditing, debugging, and reconciliation purposes.
//

model PaymentEvent {
  id                  String          @id @default(uuid()) @db.Uuid
  
  /// Payment provider that sent the event
  provider            PaymentProvider @default(STRIPE)
  
  /// Event type from the provider (e.g., "invoice.paid", "customer.subscription.deleted")
  eventType           String
  
  /// Provider's unique event ID for deduplication
  providerEventId     String          @unique
  
  /// Associated billing account (if identifiable)
  billingAccountId    String?         @db.Uuid
  
  /// Associated subscription (if identifiable)
  subscriptionId      String?         @db.Uuid
  
  /// Associated invoice (if identifiable)
  invoiceId           String?         @db.Uuid
  
  /// Raw event payload from the provider
  payload             Json
  
  /// When we finished processing this event
  processedAt         DateTime?       @db.Timestamptz
  
  /// Error message if processing failed
  error               String?
  
  createdAt           DateTime        @default(now())
  
  @@index([provider, eventType])
  @@index([billingAccountId])
  @@index([providerEventId])
  @@index([createdAt])
  @@map("payment_events")
}

// ══════════════════════════════════════════════════════════════════════════════
// PRODUCTS / SKUs
// ══════════════════════════════════════════════════════════════════════════════
//
// Products represent purchasable items in the catalog. SKUs are modeled as
// database rows for flexibility, but core SKUs are seeded on deployment.
//

model Product {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Unique SKU identifier (e.g., "SEAT_K5", "ADDON_SEL")
  sku             String        @unique
  
  /// Human-readable product name
  name            String
  
  /// Product description
  description     String?
  
  /// Product category for filtering/grouping
  category        String        // e.g., "BASE", "SEAT", "ADDON"
  
  /// Whether this product is currently available
  isActive        Boolean       @default(true)
  
  /// Unit of measure (e.g., "seat", "tenant", "module")
  unitOfMeasure   String        @default("seat")
  
  /// Sort order for display
  sortOrder       Int           @default(0)
  
  /// Metadata: features included, grade bands, module details
  /// Example: { "gradeBands": ["K-5"], "modules": ["ELA", "MATH"] }
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  priceBookEntries  PriceBookEntry[]
  contractLineItems ContractLineItem[]
  
  @@index([category, isActive])
  @@map("products")
}

// ══════════════════════════════════════════════════════════════════════════════
// PRICE BOOKS
// ══════════════════════════════════════════════════════════════════════════════
//
// Price books define standard pricing for products. Multiple price books
// support regional pricing, customer segments, or promotional pricing.
//

model PriceBook {
  id            String        @id @default(uuid()) @db.Uuid
  
  /// Price book name (e.g., "US K-12 Standard 2025", "Texas State Contract")
  name          String
  
  /// Description of this price book
  description   String?
  
  /// Currency for all entries in this price book
  currency      String        @default("USD") @db.VarChar(3)
  
  /// Whether this is the default price book for new contracts
  isDefault     Boolean       @default(false)
  
  /// Whether this price book is currently active
  isActive      Boolean       @default(true)
  
  /// Effective date - when this price book becomes valid
  effectiveFrom DateTime      @default(now()) @db.Date
  
  /// Expiration date - when this price book expires (null = no expiry)
  effectiveUntil DateTime?    @db.Date
  
  /// Metadata: region restrictions, customer segment, notes
  metadataJson  Json?
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  // Relations
  entries       PriceBookEntry[]
  contracts     Contract[]
  quotes        Quote[]
  
  @@index([isDefault, isActive])
  @@map("price_books")
}

// ══════════════════════════════════════════════════════════════════════════════
// PRICE BOOK ENTRIES
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual pricing entries within a price book. Each entry defines the
// list price for a specific SKU at a specific billing period.
//

model PriceBookEntry {
  id              String                @id @default(uuid()) @db.Uuid
  
  /// Parent price book
  priceBookId     String                @db.Uuid
  
  /// Product this entry prices
  productId       String                @db.Uuid
  
  /// SKU (denormalized for query convenience)
  sku             String
  
  /// Unit price (in major currency units, e.g., dollars not cents)
  unitPrice       Decimal               @db.Decimal(12, 2)
  
  /// Billing period this price applies to
  billingPeriod   ContractBillingPeriod @default(ANNUAL)
  
  /// Minimum quantity for this price (for tiered pricing)
  minQuantity     Int                   @default(1)
  
  /// Maximum quantity for this price tier (null = unlimited)
  maxQuantity     Int?
  
  /// Metadata: volume discounts, bundling rules, etc.
  /// Example: { "volumeTiers": [{ "minSeats": 1000, "discountPct": 5 }] }
  metadataJson    Json?
  
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  
  // Relations
  priceBook       PriceBook             @relation(fields: [priceBookId], references: [id], onDelete: Cascade)
  product         Product               @relation(fields: [productId], references: [id])
  
  @@unique([priceBookId, sku, billingPeriod, minQuantity])
  @@index([priceBookId])
  @@index([sku])
  @@map("price_book_entries")
}

// ══════════════════════════════════════════════════════════════════════════════
// DISTRICT BILLING PROFILES
// ══════════════════════════════════════════════════════════════════════════════
//
// Extended billing account information specific to district customers.
// Links to the existing BillingAccount model.
//

model DistrictBillingProfile {
  id                    String        @id @default(uuid()) @db.Uuid
  
  /// Link to the base billing account
  billingAccountId      String        @unique @db.Uuid
  
  /// Primary tenant this billing profile serves
  tenantId              String        @db.Uuid
  
  /// Billing contact name
  billingContactName    String
  
  /// Billing contact email
  billingContactEmail   String
  
  /// Billing contact phone
  billingContactPhone   String?
  
  /// Billing address as structured JSON
  /// { "line1": "...", "line2": "...", "city": "...", "state": "...", "zip": "...", "country": "..." }
  billingAddressJson    Json
  
  /// Payment terms in days (e.g., Net 30 = 30)
  paymentTermsDays      Int           @default(30)
  
  /// Tax exempt status
  isTaxExempt           Boolean       @default(true)
  
  /// Tax exemption certificate number
  taxExemptionNumber    String?
  
  /// Purchase order requirements
  requiresPO            Boolean       @default(true)
  
  /// Credit limit in cents (for invoice-based billing)
  creditLimitCents      Int?
  
  /// Metadata: additional district info, state contracts, etc.
  metadataJson          Json?
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  
  // Relations
  billingAccount        BillingAccount @relation(fields: [billingAccountId], references: [id])
  contracts             Contract[]
  
  @@index([tenantId])
  @@map("district_billing_profiles")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Contracts represent formal agreements with district customers. They define
// what products/seats are licensed, pricing terms, and contract duration.
//

model Contract {
  id                    String                @id @default(uuid()) @db.Uuid
  
  /// District billing profile this contract belongs to
  billingProfileId      String                @db.Uuid
  
  /// Tenant receiving entitlements from this contract
  tenantId              String                @db.Uuid
  
  /// Human-readable contract number (e.g., "DST-2025-00042")
  contractNumber        String                @unique
  
  /// Contract name/title
  name                  String?
  
  /// Contract start date
  startDate             DateTime              @db.Date
  
  /// Contract end date
  endDate               DateTime              @db.Date
  
  /// Current contract status
  status                ContractStatus        @default(DRAFT)
  
  /// Price book used for this contract
  priceBookId           String                @db.Uuid
  
  /// Customer's purchase order number
  poNumber              String?
  
  /// Payment type
  paymentType           ContractPaymentType   @default(INVOICE)
  
  /// Total contract value in cents (calculated from line items)
  totalValueCents       BigInt                @default(0)
  
  /// Currency
  currency              String                @default("USD") @db.VarChar(3)
  
  /// Signed date
  signedAt              DateTime?             @db.Timestamptz
  
  /// User who created the contract
  createdBy             String?               @db.Uuid
  
  /// Auto-renewal settings
  autoRenewal           Boolean               @default(false)
  
  /// Renewal notice days (days before end date to send renewal notice)
  renewalNoticeDays     Int                   @default(90)
  
  /// Parent contract (for renewals/amendments)
  parentContractId      String?               @db.Uuid
  
  /// Metadata: custom terms, legal notes, amendment history
  /// Example: { "legalTerms": "...", "specialConditions": [...] }
  metadataJson          Json?
  
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  // Relations
  billingProfile        DistrictBillingProfile @relation(fields: [billingProfileId], references: [id])
  priceBook             PriceBook              @relation(fields: [priceBookId], references: [id])
  parentContract        Contract?              @relation("ContractRenewals", fields: [parentContractId], references: [id])
  renewedContracts      Contract[]             @relation("ContractRenewals")
  lineItems             ContractLineItem[]
  invoiceSchedules      ContractInvoiceSchedule[]
  entitlements          ContractEntitlement[]
  seatEntitlements      SeatEntitlement[]
  purchaseOrders        PurchaseOrder[]
  districtInvoices      DistrictInvoice[]
  renewalTask           RenewalTask?
  marketplaceEntitlements MarketplaceEntitlement[]
  
  @@index([billingProfileId, status])
  @@index([tenantId, status])
  @@index([status, endDate])
  @@index([contractNumber])
  @@map("contracts")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT LINE ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual line items within a contract. Each line item represents a
// specific product (SKU) with quantity, pricing, and any negotiated discounts.
//

model ContractLineItem {
  id                  String                @id @default(uuid()) @db.Uuid
  
  /// Parent contract
  contractId          String                @db.Uuid
  
  /// Product being purchased
  productId           String                @db.Uuid
  
  /// SKU (denormalized)
  sku                 String
  
  /// Line item description (can override product description)
  description         String
  
  /// Billing period for this line item
  billingPeriod       ContractBillingPeriod @default(ANNUAL)
  
  /// Committed quantity (seats, units, etc.)
  quantityCommitted   Int
  
  /// Minimum quantity (for use-based billing)
  quantityMinimum     Int?
  
  /// Maximum quantity (cap)
  quantityMaximum     Int?
  
  /// List price per unit (from price book)
  listPricePerUnit    Decimal               @db.Decimal(12, 2)
  
  /// Final negotiated price per unit
  unitPrice           Decimal               @db.Decimal(12, 2)
  
  /// Discount percentage applied
  discountPercent     Decimal?              @db.Decimal(5, 2)
  
  /// Discount reason (for audit trail)
  discountReason      String?
  
  /// Total line item value in cents
  totalValueCents     BigInt                @default(0)
  
  /// Start date (if different from contract start)
  startDate           DateTime?             @db.Date
  
  /// End date (if different from contract end)
  endDate             DateTime?             @db.Date
  
  /// Metadata: grade bands, school allocations, etc.
  /// Example: { "gradeBands": ["K-5"], "schoolAllocations": { "school-uuid": 500 } }
  metadataJson        Json?
  
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  
  // Relations
  contract            Contract              @relation(fields: [contractId], references: [id], onDelete: Cascade)
  product             Product               @relation(fields: [productId], references: [id])
  allocations         ContractAllocation[]
  marketplaceEntitlements MarketplaceEntitlement[]
  
  @@index([contractId, sku])
  @@index([sku])
  @@map("contract_line_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT ALLOCATIONS
// ══════════════════════════════════════════════════════════════════════════════
//
// Allocations distribute contract line items across schools within a district.
// This enables tracking seat usage and entitlements at the school level.
//

model ContractAllocation {
  id                String              @id @default(uuid()) @db.Uuid
  
  /// Parent line item
  lineItemId        String              @db.Uuid
  
  /// School receiving the allocation
  schoolId          String              @db.Uuid
  
  /// Quantity allocated to this school
  quantityAllocated Int
  
  /// Quantity currently used
  quantityUsed      Int                 @default(0)
  
  /// Metadata: additional allocation details
  metadataJson      Json?
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relations
  lineItem          ContractLineItem    @relation(fields: [lineItemId], references: [id], onDelete: Cascade)
  
  @@unique([lineItemId, schoolId])
  @@index([schoolId])
  @@map("contract_allocations")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT ENTITLEMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Entitlements represent the actual features/access granted by a contract.
// These are the runtime permissions checked by the product.
//

model ContractEntitlement {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Parent contract
  contractId      String        @db.Uuid
  
  /// Tenant receiving the entitlement
  tenantId        String        @db.Uuid
  
  /// Feature/module being entitled (e.g., "MODULE_SEL", "GRADE_K5")
  featureKey      String
  
  /// Whether this entitlement is currently active
  isActive        Boolean       @default(true)
  
  /// Quantity/limit (e.g., seat count)
  quantity        Int?
  
  /// Effective start date
  startDate       DateTime      @db.Date
  
  /// Effective end date
  endDate         DateTime      @db.Date
  
  /// Metadata: feature-specific config
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  contract        Contract      @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  @@unique([contractId, featureKey])
  @@index([tenantId, featureKey, isActive])
  @@index([tenantId, endDate])
  @@map("contract_entitlements")
}

// ══════════════════════════════════════════════════════════════════════════════
// SEAT ENTITLEMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Seat entitlements are derived from contract line items for seat-based SKUs.
// They track seat allocation and usage for each tenant/grade band combination.
// This enables runtime enforcement of seat limits.
//

/// Grade band for seat licensing
enum GradeBand {
  K_2       // Kindergarten through 2nd grade
  G3_5      // Grades 3-5
  G6_8      // Grades 6-8
  G9_12     // Grades 9-12
  TEACHER   // Teacher licenses
  ALL       // All grades (for add-on modules)
}

/// Type of license bundle
enum BundleType {
  FAMILY          // Individual family subscription (1 learner + 1 parent + 1 teacher)
  CLASSROOM       // Classroom bundle (multiple learners + 1 teacher + parents)
  DISTRICT_SEAT   // District seat bundle (1 learner + parent access + teacher access)
}

/// Origin of the bundle assignment
enum BundleOrigin {
  DISTRICT_ENROLLMENT   // Child enrolled by district/school
  PARENT_SUBSCRIPTION   // Parent purchased subscription
  TEACHER_ASSIGNMENT    // Teacher assigned from school pool
}

/// Enforcement mode for seat caps
enum SeatCapEnforcement {
  SOFT      // Allow overage with warnings
  HARD      // Block new assignments when limit reached
  UNLIMITED // No enforcement (rare)
}

model SeatEntitlement {
  id                    String              @id @default(uuid()) @db.Uuid
  
  /// Tenant this entitlement belongs to
  tenantId              String              @db.Uuid
  
  /// Parent contract
  contractId            String              @db.Uuid
  
  /// Contract line item this was derived from
  lineItemId            String              @db.Uuid
  
  /// SKU for this entitlement (e.g., "SEAT_K5", "SEAT_6_8")
  sku                   String
  
  /// Grade band (derived from SKU)
  gradeBand             GradeBand
  
  /// Total committed seats from contract
  quantityCommitted     Int
  
  /// Currently allocated/assigned seats
  quantityAllocated     Int                 @default(0)
  
  /// Whether overage is allowed
  overageAllowed        Boolean             @default(false)
  
  /// Maximum allowed overage (null = unlimited if allowed)
  overageLimit          Int?
  
  /// Current overage count (seats over committed amount)
  overageCount          Int                 @default(0)
  
  /// Enforcement mode for this entitlement
  enforcement           SeatCapEnforcement  @default(SOFT)
  
  /// Effective start date
  startDate             DateTime            @db.Date
  
  /// Effective end date
  endDate               DateTime            @db.Date
  
  /// Whether this entitlement is currently active
  isActive              Boolean             @default(true)
  
  /// Metadata: school allocations, usage history, etc.
  metadataJson          Json?
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Relations
  contract              Contract            @relation(fields: [contractId], references: [id], onDelete: Cascade)
  licenseAssignments    LicenseAssignment[]
  
  @@unique([tenantId, contractId, sku])
  @@index([tenantId, gradeBand, isActive])
  @@index([contractId])
  @@index([tenantId, endDate])
  @@map("seat_entitlements")
}

// ══════════════════════════════════════════════════════════════════════════════
// LICENSE ASSIGNMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual seat license assignments to learners (or teachers for add-ons).
// Tracks the lifecycle of each assigned seat for audit and compliance.
//

/// Status of a license assignment
enum LicenseAssignmentStatus {
  ACTIVE      // Currently assigned and valid
  REVOKED     // Manually revoked (e.g., learner transferred out)
  EXPIRED     // Contract/entitlement expired
  TRANSFERRED // Transferred to different grade band
}

model LicenseAssignment {
  id                  String                    @id @default(uuid()) @db.Uuid
  
  /// Tenant this assignment belongs to
  tenantId            String                    @db.Uuid
  
  /// Parent seat entitlement
  entitlementId       String                    @db.Uuid
  
  /// Learner receiving this license (null for add-on module entitlements)
  learnerId           String?                   @db.Uuid
  
  /// Teacher receiving this license (for teacher-specific add-ons)
  teacherId           String?                   @db.Uuid
  
  /// SKU for this assignment
  sku                 String
  
  /// Grade band at time of assignment
  gradeBand           GradeBand
  
  /// School ID (for school-level tracking)
  schoolId            String?                   @db.Uuid
  
  /// Assignment status
  status              LicenseAssignmentStatus   @default(ACTIVE)
  
  /// Whether this was an overage assignment
  isOverage           Boolean                   @default(false)
  
  /// When the license was assigned
  assignedAt          DateTime                  @default(now()) @db.Timestamptz
  
  /// When the license was revoked (null if still active)
  revokedAt           DateTime?                 @db.Timestamptz
  
  /// Reason for revocation (if revoked)
  revokedReason       String?
  
  /// User who made the assignment (for audit)
  assignedBy          String?                   @db.Uuid
  
  /// User who revoked (for audit)
  revokedBy           String?                   @db.Uuid
  
  /// Previous assignment ID (for grade band transfers)
  previousAssignmentId String?                  @db.Uuid
  
  /// Metadata: assignment context, source system, etc.
  metadataJson        Json?
  
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt
  
  // Relations
  entitlement         SeatEntitlement           @relation(fields: [entitlementId], references: [id], onDelete: Cascade)
  previousAssignment  LicenseAssignment?        @relation("LicenseTransfers", fields: [previousAssignmentId], references: [id])
  transferredTo       LicenseAssignment[]       @relation("LicenseTransfers")
  
  @@index([tenantId, learnerId, status])
  @@index([tenantId, gradeBand, status])
  @@index([entitlementId, status])
  @@index([schoolId, status])
  @@index([learnerId])
  @@index([teacherId])
  @@map("license_assignments")
}

// ══════════════════════════════════════════════════════════════════════════════
// LICENSE BUNDLES
// ══════════════════════════════════════════════════════════════════════════════
//
// License bundles represent packaged licenses that include learner, parent,
// and teacher access. Bundles can originate from district enrollment or
// parent subscription, supporting bi-directional enrollment flows.
//

/// Status of a license bundle
enum LicenseBundleStatus {
  PENDING     // Bundle created, awaiting all parties to activate
  ACTIVE      // All parties have access
  SUSPENDED   // Temporarily suspended (e.g., payment issue)
  EXPIRED     // Bundle has expired
  CANCELLED   // Bundle was cancelled
}

model LicenseBundle {
  id                    String              @id @default(uuid()) @db.Uuid

  /// Tenant this bundle belongs to
  tenantId              String              @db.Uuid

  /// Bundle type
  bundleType            BundleType

  /// Origin of this bundle
  origin                BundleOrigin

  /// Current bundle status
  status                LicenseBundleStatus @default(PENDING)

  /// Primary learner for this bundle
  learnerId             String              @db.Uuid

  /// Parent user linked to this bundle (null until parent accepts invite)
  parentUserId          String?             @db.Uuid

  /// Teacher user linked to this bundle (null until teacher is assigned/invited)
  teacherUserId         String?             @db.Uuid

  /// School ID (for school-based bundles)
  schoolId              String?             @db.Uuid

  /// Contract ID (for district-originated bundles)
  contractId            String?             @db.Uuid

  /// Subscription ID (for parent-originated bundles)
  subscriptionId        String?             @db.Uuid

  /// Seat entitlement ID (for tracking seat allocation)
  seatEntitlementId     String?             @db.Uuid

  /// Learner license assignment ID
  learnerAssignmentId   String?             @db.Uuid

  /// Teacher license assignment ID
  teacherAssignmentId   String?             @db.Uuid

  /// Grade band for this bundle
  gradeBand             GradeBand

  /// Bundle effective start date
  startDate             DateTime            @db.Date

  /// Bundle effective end date
  endDate               DateTime            @db.Date

  /// Modules included in bundle
  /// Example: ["ELA", "MATH", "SEL"]
  modulesJson           Json?

  /// Parent invite ID (from parent-svc, for tracking invite status)
  parentInviteId        String?

  /// Teacher invite ID (for tracking teacher invite status)
  teacherInviteId       String?

  /// Who created this bundle
  createdBy             String?             @db.Uuid

  /// Metadata: additional bundle context
  metadataJson          Json?

  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt

  // Relations
  bundleEvents          LicenseBundleEvent[]

  @@index([tenantId, status])
  @@index([learnerId])
  @@index([parentUserId])
  @@index([teacherUserId])
  @@index([contractId])
  @@index([subscriptionId])
  @@index([status, endDate])
  @@map("license_bundles")
}

/// Type of bundle event
enum LicenseBundleEventType {
  BUNDLE_CREATED          // Bundle was created
  PARENT_INVITED          // Parent invitation sent
  PARENT_ACCEPTED         // Parent accepted invitation
  TEACHER_INVITED         // Teacher invitation sent
  TEACHER_ACCEPTED        // Teacher accepted/was assigned
  BUNDLE_ACTIVATED        // Bundle fully activated
  BUNDLE_SUSPENDED        // Bundle suspended
  BUNDLE_REACTIVATED      // Bundle reactivated
  BUNDLE_EXPIRED          // Bundle expired
  BUNDLE_CANCELLED        // Bundle cancelled
  PARENT_CHANGED          // Parent user changed
  TEACHER_CHANGED         // Teacher user changed
}

model LicenseBundleEvent {
  id              String                  @id @default(uuid()) @db.Uuid

  /// Parent bundle
  bundleId        String                  @db.Uuid

  /// Tenant
  tenantId        String                  @db.Uuid

  /// Event type
  eventType       LicenseBundleEventType

  /// Actor who triggered event
  actorId         String?                 @db.Uuid

  /// Actor type
  actorType       String                  @default("SYSTEM") // SYSTEM, PARENT, TEACHER, ADMIN

  /// Event description
  description     String

  /// Previous state
  previousValue   Json?

  /// New state
  newValue        Json?

  /// Additional context
  metadataJson    Json?

  createdAt       DateTime                @default(now()) @db.Timestamptz

  // Relations
  bundle          LicenseBundle           @relation(fields: [bundleId], references: [id], onDelete: Cascade)

  @@index([bundleId])
  @@index([tenantId, eventType])
  @@index([tenantId, createdAt])
  @@map("license_bundle_events")
}

// ══════════════════════════════════════════════════════════════════════════════
// TEACHER INVITES
// ══════════════════════════════════════════════════════════════════════════════
//
// Teacher invitations for parent-initiated enrollment flow.
// When a parent subscribes, they can invite their child's teacher.
//

/// Status of a teacher invite
enum TeacherInviteStatus {
  PENDING     // Invite sent, awaiting acceptance
  ACCEPTED    // Teacher accepted
  DECLINED    // Teacher declined
  EXPIRED     // Invite expired
  REVOKED     // Invite was revoked
}

model TeacherInvite {
  id                String              @id @default(uuid()) @db.Uuid

  /// Unique invite code
  code              String              @unique

  /// Tenant
  tenantId          String              @db.Uuid

  /// Bundle this invite is for
  bundleId          String              @db.Uuid

  /// Learner the teacher will be assigned to
  learnerId         String              @db.Uuid

  /// Teacher email
  teacherEmail      String

  /// Teacher name (optional, for display)
  teacherName       String?

  /// School name (for context)
  schoolName        String?

  /// Invite status
  status            TeacherInviteStatus @default(PENDING)

  /// Parent who sent the invite
  invitedByParentId String              @db.Uuid

  /// Teacher user ID (once accepted)
  teacherUserId     String?             @db.Uuid

  /// Preferred language for invite email
  language          String              @default("en")

  /// When invite expires
  expiresAt         DateTime            @db.Timestamptz

  /// When invite was accepted
  acceptedAt        DateTime?           @db.Timestamptz

  /// Message from parent to teacher
  message           String?

  /// Metadata
  metadataJson      Json?

  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@index([code])
  @@index([teacherEmail])
  @@index([bundleId])
  @@index([learnerId])
  @@index([status])
  @@map("teacher_invites")
}

// ══════════════════════════════════════════════════════════════════════════════
// BULK INVITE BATCHES
// ══════════════════════════════════════════════════════════════════════════════
//
// Tracks bulk invitation operations for district admin enrollment workflows.
//

/// Status of a bulk invite batch
enum BulkInviteBatchStatus {
  PENDING     // Batch created, processing not started
  PROCESSING  // Currently sending invites
  COMPLETED   // All invites processed
  FAILED      // Batch failed
  CANCELLED   // Batch was cancelled
}

model BulkInviteBatch {
  id                  String                @id @default(uuid()) @db.Uuid

  /// Tenant
  tenantId            String                @db.Uuid

  /// Batch type: 'parent' or 'teacher'
  inviteType          String                // parent, teacher

  /// Batch status
  status              BulkInviteBatchStatus @default(PENDING)

  /// Total invites in batch
  totalCount          Int

  /// Successfully sent
  successCount        Int                   @default(0)

  /// Failed to send
  failedCount         Int                   @default(0)

  /// Skipped (e.g., already invited)
  skippedCount        Int                   @default(0)

  /// User who initiated the batch
  createdBy           String                @db.Uuid

  /// School filter (if applicable)
  schoolId            String?               @db.Uuid

  /// Class/grade filter (if applicable)
  classId             String?               @db.Uuid

  /// Source file reference (for CSV uploads)
  sourceFileUrl       String?

  /// Processing started at
  processingStartedAt DateTime?             @db.Timestamptz

  /// Processing completed at
  processingCompletedAt DateTime?           @db.Timestamptz

  /// Error details for failed items
  /// Example: [{ "email": "...", "error": "invalid email" }]
  errorsJson          Json?

  /// Metadata
  metadataJson        Json?

  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt

  // Relations
  items               BulkInviteItem[]

  @@index([tenantId, status])
  @@index([createdBy])
  @@index([status, createdAt])
  @@map("bulk_invite_batches")
}

model BulkInviteItem {
  id              String    @id @default(uuid()) @db.Uuid

  /// Parent batch
  batchId         String    @db.Uuid

  /// Learner ID
  learnerId       String    @db.Uuid

  /// Recipient email
  email           String

  /// Recipient name
  name            String?

  /// Item status: pending, sent, failed, skipped
  status          String    @default("pending")

  /// Error message if failed
  error           String?

  /// Created invite ID (once sent)
  inviteId        String?

  /// Bundle ID (if bundle was created)
  bundleId        String?   @db.Uuid

  /// Processed at
  processedAt     DateTime? @db.Timestamptz

  createdAt       DateTime  @default(now())

  // Relations
  batch           BulkInviteBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@index([batchId, status])
  @@index([learnerId])
  @@index([email])
  @@map("bulk_invite_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// LICENSE EVENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Audit log for all licensing events - assignments, revocations, overages, etc.
// Used for compliance reporting and troubleshooting.
//

/// Type of license event
enum LicenseEventType {
  ENTITLEMENT_CREATED     // New entitlement synced from contract
  ENTITLEMENT_UPDATED     // Entitlement quantity changed
  ENTITLEMENT_EXPIRED     // Entitlement reached end date
  LICENSE_ASSIGNED        // Seat assigned to learner
  LICENSE_REVOKED         // Seat revoked from learner
  LICENSE_TRANSFERRED     // Seat moved to different grade band
  OVERAGE_WARNING         // Soft cap warning triggered
  OVERAGE_BLOCKED         // Hard cap blocked assignment
  CAP_ADJUSTED            // Admin adjusted cap settings
}

model LicenseEvent {
  id                String            @id @default(uuid()) @db.Uuid
  
  /// Tenant this event belongs to
  tenantId          String            @db.Uuid
  
  /// Event type
  eventType         LicenseEventType
  
  /// Related entitlement (if applicable)
  entitlementId     String?           @db.Uuid
  
  /// Related license assignment (if applicable)
  assignmentId      String?           @db.Uuid
  
  /// Related learner (if applicable)
  learnerId         String?           @db.Uuid
  
  /// User who triggered the event (system if automated)
  actorId           String?           @db.Uuid
  
  /// Actor type
  actorType         String            @default("SYSTEM") // SYSTEM, USER, API
  
  /// Event description
  description       String
  
  /// Previous state (for changes)
  previousValue     Json?
  
  /// New state (for changes)
  newValue          Json?
  
  /// Additional event context
  metadataJson      Json?
  
  createdAt         DateTime          @default(now()) @db.Timestamptz
  
  @@index([tenantId, eventType])
  @@index([tenantId, createdAt])
  @@index([entitlementId])
  @@index([assignmentId])
  @@index([learnerId])
  @@map("license_events")
}

// ══════════════════════════════════════════════════════════════════════════════
// QUOTES
// ══════════════════════════════════════════════════════════════════════════════
//
// Quotes represent pricing proposals sent to district prospects/customers.
// Created by Aivo sales team, shared with districts, can be accepted to
// trigger PO/contract creation.
//

/// Status of a quote in the sales pipeline
enum QuoteStatus {
  DRAFT     // Being prepared, not yet shared
  SENT      // Shared with district, awaiting response
  ACCEPTED  // District accepted, ready for PO/contract
  REJECTED  // District declined
  EXPIRED   // Past validity date without response
  CONVERTED // Successfully converted to contract
}

model Quote {
  id                  String        @id @default(uuid()) @db.Uuid
  
  /// Billing account this quote is for
  billingAccountId    String        @db.Uuid
  
  /// Tenant this quote is for
  tenantId            String        @db.Uuid
  
  /// Human-readable quote number (e.g., "Q-2025-00042")
  quoteNumber         String        @unique
  
  /// Quote name/title
  name                String?
  
  /// Current quote status
  status              QuoteStatus   @default(DRAFT)
  
  /// Quote validity end date
  validUntil          DateTime      @db.Date
  
  /// Currency
  currency            String        @default("USD") @db.VarChar(3)
  
  /// Total quote amount in cents
  totalAmountCents    BigInt        @default(0)
  
  /// Price book used for this quote
  priceBookId         String?       @db.Uuid
  
  /// Contract term start (proposed)
  proposedStartDate   DateTime?     @db.Date
  
  /// Contract term end (proposed)
  proposedEndDate     DateTime?     @db.Date
  
  /// Payment terms in days (e.g., Net 30)
  paymentTermsDays    Int           @default(30)
  
  /// When the quote was sent to the district
  sentAt              DateTime?     @db.Timestamptz
  
  /// When the district accepted the quote
  acceptedAt          DateTime?     @db.Timestamptz
  
  /// User who created the quote (Aivo internal)
  createdBy           String?       @db.Uuid
  
  /// Contract created from this quote (after conversion)
  convertedContractId String?       @db.Uuid
  
  /// Metadata: notes, internal comments, revision history
  /// Example: { "internalNotes": "...", "districtContact": "...", "revision": 2 }
  metadataJson        Json?
  
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  
  // Relations
  lineItems           QuoteLineItem[]
  purchaseOrders      PurchaseOrder[]
  priceBook           PriceBook?     @relation(fields: [priceBookId], references: [id])
  
  @@index([billingAccountId, status])
  @@index([tenantId, status])
  @@index([status, validUntil])
  @@index([quoteNumber])
  @@map("quotes")
}

// ══════════════════════════════════════════════════════════════════════════════
// QUOTE LINE ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual line items within a quote. Each represents a product/service
// being proposed with quantity and pricing.
//

model QuoteLineItem {
  id                String    @id @default(uuid()) @db.Uuid
  
  /// Parent quote
  quoteId           String    @db.Uuid
  
  /// Product SKU
  sku               String
  
  /// Line item description
  description       String
  
  /// Quantity
  quantity          Int       @default(1)
  
  /// List price per unit in cents (from price book)
  listPriceCents    BigInt
  
  /// Unit price after discounts in cents
  unitPriceCents    BigInt
  
  /// Discount percentage applied (0-100)
  discountPercent   Decimal?  @db.Decimal(5, 2)
  
  /// Total line amount in cents (unitPriceCents * quantity)
  totalAmountCents  BigInt    @default(0)
  
  /// Sort order for display
  sortOrder         Int       @default(0)
  
  /// Metadata: product details, notes
  metadataJson      Json?
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  quote             Quote     @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  
  @@index([quoteId])
  @@map("quote_line_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// PURCHASE ORDERS
// ══════════════════════════════════════════════════════════════════════════════
//
// Purchase orders received from districts. POs are required for most district
// contracts and link quotes to contracts.
//

/// Status of a purchase order
enum POStatus {
  PENDING   // Received, awaiting Aivo approval
  APPROVED  // Approved, ready for contract activation
  REJECTED  // Rejected (e.g., amount mismatch, invalid)
  CLOSED    // Fully processed, contract activated
  CANCELLED // Cancelled by district
}

model PurchaseOrder {
  id                  String      @id @default(uuid()) @db.Uuid
  
  /// Billing account this PO belongs to
  billingAccountId    String      @db.Uuid
  
  /// Tenant this PO is for
  tenantId            String      @db.Uuid
  
  /// District's PO number (from their system)
  poNumber            String
  
  /// Quote this PO references (if from a quote)
  quoteId             String?     @db.Uuid
  
  /// Current PO status
  status              POStatus    @default(PENDING)
  
  /// PO amount in cents
  amountCents         BigInt
  
  /// Currency
  currency            String      @default("USD") @db.VarChar(3)
  
  /// PO validity start date
  validFrom           DateTime    @db.Date
  
  /// PO validity end date
  validTo             DateTime    @db.Date
  
  /// Uploaded PO document references
  /// Example: [{ "fileName": "PO-2025.pdf", "url": "...", "uploadedAt": "..." }]
  attachmentsJson     Json?
  
  /// Aivo user who approved/rejected
  reviewedBy          String?     @db.Uuid
  
  /// When the PO was reviewed
  reviewedAt          DateTime?   @db.Timestamptz
  
  /// Review notes/reason for rejection
  reviewNotes         String?
  
  /// Contract created from this PO
  contractId          String?     @db.Uuid
  
  /// Metadata: additional PO details
  metadataJson        Json?
  
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt
  
  // Relations
  quote               Quote?      @relation(fields: [quoteId], references: [id])
  contract            Contract?   @relation(fields: [contractId], references: [id])
  
  @@unique([tenantId, poNumber])
  @@index([billingAccountId, status])
  @@index([tenantId, status])
  @@index([status])
  @@index([poNumber])
  @@map("purchase_orders")
}

// ══════════════════════════════════════════════════════════════════════════════
// DISTRICT INVOICES
// ══════════════════════════════════════════════════════════════════════════════
//
// Invoices for district contracts. Extends the base Invoice model with
// district-specific features like PO references and external ERP integration.
//

/// Status of a district invoice
enum DistrictInvoiceStatus {
  DRAFT     // Being prepared
  SENT      // Sent to district
  PAID      // Payment received
  OVERDUE   // Past due date
  VOID      // Cancelled/voided
  DISPUTED  // District has raised a dispute
}

model DistrictInvoice {
  id                  String                  @id @default(uuid()) @db.Uuid
  
  /// Billing account this invoice belongs to
  billingAccountId    String                  @db.Uuid
  
  /// Contract this invoice is for
  contractId          String                  @db.Uuid
  
  /// Human-readable invoice number (e.g., "INV-2025-00042")
  invoiceNumber       String                  @unique
  
  /// Current invoice status
  status              DistrictInvoiceStatus   @default(DRAFT)
  
  /// Invoice issue date
  issueDate           DateTime                @db.Date
  
  /// Payment due date
  dueDate             DateTime                @db.Date
  
  /// Total amount due in cents
  amountDueCents      BigInt
  
  /// Amount paid in cents
  amountPaidCents     BigInt                  @default(0)
  
  /// Currency
  currency            String                  @default("USD") @db.VarChar(3)
  
  /// PO number for reference (from district's PO)
  poNumber            String?
  
  /// External system ID (Stripe, ERP, etc.)
  externalSystemId    String?
  
  /// External system name (e.g., "STRIPE", "QUICKBOOKS", "NETSUITE")
  externalSystemName  String?
  
  /// When the invoice was sent to the district
  sentAt              DateTime?               @db.Timestamptz
  
  /// When payment was received
  paidAt              DateTime?               @db.Timestamptz
  
  /// Payment reference (check number, wire reference, etc.)
  paymentReference    String?
  
  /// PDF URL or path
  pdfUrl              String?
  
  /// Metadata: line item breakdown, notes, reminders sent
  /// Example: { "lineItems": [...], "remindersSent": 2 }
  metadataJson        Json?
  
  createdAt           DateTime                @default(now())
  updatedAt           DateTime                @updatedAt
  
  // Relations
  contract            Contract                @relation(fields: [contractId], references: [id])
  
  @@index([billingAccountId, status])
  @@index([contractId, status])
  @@index([status, dueDate])
  @@index([invoiceNumber])
  @@index([externalSystemId])
  @@map("district_invoices")
}

// ══════════════════════════════════════════════════════════════════════════════
// RENEWAL TASKS
// ══════════════════════════════════════════════════════════════════════════════
//
// Scheduled renewal tasks for contracts approaching end date.
// Used by the renewal scheduler to track and manage upcoming renewals.
//

/// Status of a renewal task
enum RenewalTaskStatus {
  SCHEDULED     // Upcoming, not yet actionable
  DUE           // Ready for action
  IN_PROGRESS   // Being worked on
  COMPLETED     // Successfully renewed
  NOT_RENEWING  // Customer decided not to renew
  CHURNED       // Contract ended without renewal
}

model RenewalTask {
  id                  String            @id @default(uuid()) @db.Uuid
  
  /// Contract being renewed
  contractId          String            @db.Uuid
  
  /// Tenant
  tenantId            String            @db.Uuid
  
  /// Task status
  status              RenewalTaskStatus @default(SCHEDULED)
  
  /// Scheduled due date (when to start renewal process)
  dueDate             DateTime          @db.Date
  
  /// Contract end date (for reference)
  contractEndDate     DateTime          @db.Date
  
  /// Draft renewal quote (if created)
  renewalQuoteId      String?           @db.Uuid
  
  /// Renewal contract (if created)
  renewalContractId   String?           @db.Uuid
  
  /// Assigned account manager
  assignedTo          String?           @db.Uuid
  
  /// Notes and activity log
  /// Example: { "activities": [{ "date": "...", "action": "...", "by": "..." }] }
  notesJson           Json?
  
  /// Last reminder sent date
  lastReminderAt      DateTime?         @db.Timestamptz
  
  /// Number of reminders sent
  reminderCount       Int               @default(0)
  
  /// Churn reason (if not renewing)
  churnReason         String?
  
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  
  // Relations
  contract            Contract          @relation(fields: [contractId], references: [id])
  
  @@unique([contractId])
  @@index([status, dueDate])
  @@index([tenantId, status])
  @@index([assignedTo, status])
  @@map("renewal_tasks")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT INVOICE SCHEDULE
// ══════════════════════════════════════════════════════════════════════════════
//
// Defines the invoicing schedule for a contract. Supports various billing
// patterns (annual upfront, quarterly, milestone-based, etc.).
//

model ContractInvoiceSchedule {
  id                String          @id @default(uuid()) @db.Uuid
  
  /// Parent contract
  contractId        String          @db.Uuid
  
  /// Scheduled invoice date
  scheduledDate     DateTime        @db.Date
  
  /// Invoice amount in cents
  amountCents       BigInt
  
  /// Description/milestone name
  description       String?
  
  /// Invoice ID (once generated)
  invoiceId         String?         @db.Uuid
  
  /// Status of this schedule item
  status            String          @default("PENDING") // PENDING, INVOICED, PAID, CANCELLED
  
  /// Metadata: period covered, line item breakdown, etc.
  metadataJson      Json?
  
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relations
  contract          Contract        @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  @@index([contractId, status])
  @@index([scheduledDate, status])
  @@map("contract_invoice_schedules")
}

// ══════════════════════════════════════════════════════════════════════════════
// SEAT USAGE ANALYTICS & ALERTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Threshold-based alerting for seat utilization. Generated by daily job when
// usage exceeds defined thresholds (80%, 100%, 110%).
//

/// Status of a seat usage alert
enum SeatUsageAlertStatus {
  OPEN          // Alert active, needs attention
  ACKNOWLEDGED  // Admin has seen the alert
  RESOLVED      // Resolved (either reduced usage or increased capacity)
}

model SeatUsageAlert {
  id                String                @id @default(uuid()) @db.Uuid
  
  /// Tenant this alert belongs to
  tenantId          String                @db.Uuid
  
  /// SKU for the entitlement
  sku               String
  
  /// Grade band (matches entitlement)
  gradeBand         GradeBand
  
  /// Threshold that was exceeded (0.80, 1.00, 1.10)
  threshold         Decimal               @db.Decimal(4, 2)
  
  /// Alert status
  status            SeatUsageAlertStatus  @default(OPEN)
  
  /// Snapshot of usage values at alert creation
  /// Example: { "committed": 100, "allocated": 85, "utilization": 85, "overage": 0 }
  contextJson       Json?
  
  /// When the alert was acknowledged
  acknowledgedAt    DateTime?             @db.Timestamptz
  
  /// User who acknowledged the alert
  acknowledgedBy    String?               @db.Uuid
  
  /// When the alert was resolved
  resolvedAt        DateTime?             @db.Timestamptz
  
  /// User who resolved the alert
  resolvedBy        String?               @db.Uuid
  
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  // Relations
  notifications     SeatUsageNotification[]
  
  @@index([tenantId, status])
  @@index([tenantId, sku, threshold])
  @@index([status, createdAt(sort: Desc)])
  @@map("seat_usage_alerts")
}

// ══════════════════════════════════════════════════════════════════════════════
// SEAT USAGE NOTIFICATIONS
// ══════════════════════════════════════════════════════════════════════════════
//
// In-app notifications for seat usage alerts. Displayed to district admins
// and platform CSM team.
//

model SeatUsageNotification {
  id            String            @id @default(uuid()) @db.Uuid
  
  /// Parent alert
  alertId       String            @db.Uuid
  
  /// Tenant this notification belongs to
  tenantId      String            @db.Uuid
  
  /// User to notify (null for system-wide)
  userId        String?           @db.Uuid
  
  /// Notification title
  title         String
  
  /// Notification message
  message       String
  
  /// Severity level
  severity      String            @default("WARNING") // INFO, WARNING, CRITICAL
  
  /// Whether the notification has been read
  isRead        Boolean           @default(false)
  
  /// When the notification was read
  readAt        DateTime?         @db.Timestamptz
  
  
  createdAt     DateTime          @default(now())
  
  // Relations
  alert         SeatUsageAlert    @relation(fields: [alertId], references: [id], onDelete: Cascade)
  
  @@index([tenantId, userId, isRead])
  @@index([alertId])
  @@map("seat_usage_notifications")
}

// ══════════════════════════════════════════════════════════════════════════════
// MARKETPLACE ENTITLEMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Entitlements specific to marketplace items. Tracks what marketplace items
// a tenant has access to based on their contract.
//

/// Payout status for vendor revenue sharing
enum VendorPayoutStatus {
  PENDING   // Calculated, awaiting approval
  APPROVED  // Approved for payment
  PAID      // Payment completed
  DISPUTED  // Under dispute/review
}

/// Marketplace item entitlement linked to a contract
model MarketplaceEntitlement {
  id                        String    @id @default(uuid()) @db.Uuid
  
  /// Tenant receiving the entitlement
  tenantId                  String    @map("tenant_id") @db.Uuid
  
  /// Parent contract (if contract-based)
  contractId                String?   @map("contract_id") @db.Uuid
  
  /// Contract line item this was derived from
  lineItemId                String?   @map("line_item_id") @db.Uuid
  
  /// Marketplace item ID (cross-service FK to marketplace-svc)
  marketplaceItemId         String    @map("marketplace_item_id") @db.Uuid
  
  /// Marketplace installation ID (cross-service FK)
  marketplaceInstallationId String    @map("marketplace_installation_id") @db.Uuid
  
  /// SKU for billing
  sku                       String
  
  /// Feature key (e.g., "MARKETPLACE_ITEM:{item_id}")
  featureKey                String    @map("feature_key")
  
  /// Whether entitlement is active
  isActive                  Boolean   @default(true) @map("is_active")
  
  /// Quantity (for PER_SEAT: seat count)
  quantity                  Int?
  
  /// Effective start date
  startDate                 DateTime  @map("start_date") @db.Date
  
  /// Effective end date
  endDate                   DateTime  @map("end_date") @db.Date
  
  /// Metadata: installation config, etc.
  metadataJson              Json?     @map("metadata_json")
  
  createdAt                 DateTime  @default(now()) @map("created_at")
  updatedAt                 DateTime  @updatedAt @map("updated_at")

  // Relations
  contract                  Contract? @relation(fields: [contractId], references: [id], onDelete: Cascade)
  lineItem                  ContractLineItem? @relation(fields: [lineItemId], references: [id], onDelete: Cascade)

  @@unique([tenantId, marketplaceItemId, contractId])
  @@index([tenantId, isActive])
  @@index([contractId])
  @@index([marketplaceItemId, tenantId])
  @@index([sku])
  @@map("marketplace_entitlements")
}

// ══════════════════════════════════════════════════════════════════════════════
// VENDOR REVENUE SHARE CACHE
// ══════════════════════════════════════════════════════════════════════════════
//
// Cached vendor revenue share data from marketplace-svc.
// Used for revenue reporting and vendor payouts.
//

/// Cached vendor revenue share configuration (synced from marketplace-svc)
model VendorRevenueShareCache {
  id                  String    @id @db.Uuid
  
  /// Vendor ID (from marketplace-svc)
  vendorId            String    @map("vendor_id") @db.Uuid
  
  /// Vendor name (denormalized)
  vendorName          String    @map("vendor_name")
  
  /// SKU this share applies to
  sku                 String
  
  /// Vendor share percentage (e.g., 30.00 = 30%)
  sharePercent        Decimal   @map("share_percent") @db.Decimal(5, 2)
  
  /// Effective start date
  effectiveStartDate  DateTime  @map("effective_start_date") @db.Date
  
  /// Effective end date (null = ongoing)
  effectiveEndDate    DateTime? @map("effective_end_date") @db.Date
  
  /// When this data was synced
  syncedAt            DateTime  @default(now()) @map("synced_at") @db.Timestamptz

  @@index([sku, effectiveStartDate, effectiveEndDate])
  @@index([vendorId])
  @@map("vendor_revenue_share_cache")
}

// ══════════════════════════════════════════════════════════════════════════════
// VENDOR PAYOUTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Tracks vendor payout records for revenue sharing reconciliation and audit.
//

/// Vendor payout record for revenue sharing
model VendorPayout {
  id                  String              @id @default(uuid()) @db.Uuid
  
  /// Vendor ID (from marketplace-svc)
  vendorId            String              @map("vendor_id") @db.Uuid
  
  /// Vendor name (denormalized)
  vendorName          String              @map("vendor_name")
  
  /// Payout period start
  periodStart         DateTime            @map("period_start") @db.Date
  
  /// Payout period end
  periodEnd           DateTime            @map("period_end") @db.Date
  
  /// Gross revenue in cents
  grossRevenueCents   BigInt              @map("gross_revenue_cents")
  
  /// Vendor share percentage applied
  vendorSharePercent  Decimal             @map("vendor_share_percent") @db.Decimal(5, 2)
  
  /// Vendor amount in cents
  vendorAmountCents   BigInt              @map("vendor_amount_cents")
  
  /// Payout status
  status              VendorPayoutStatus  @default(PENDING)
  
  /// When payout was calculated
  calculatedAt        DateTime            @default(now()) @map("calculated_at") @db.Timestamptz
  
  /// When payout was approved
  approvedAt          DateTime?           @map("approved_at") @db.Timestamptz
  
  /// User who approved
  approvedBy          String?             @map("approved_by") @db.Uuid
  
  /// When payout was sent
  paidAt              DateTime?           @map("paid_at") @db.Timestamptz
  
  /// External payment reference
  paymentReference    String?             @map("payment_reference")
  
  /// Breakdown by SKU
  lineItemsJson       Json?               @map("line_items_json")
  
  /// Notes
  notes               String?
  
  createdAt           DateTime            @default(now()) @map("created_at")
  updatedAt           DateTime            @updatedAt @map("updated_at")

  @@index([vendorId, status])
  @@index([periodStart, periodEnd])
  @@index([status, createdAt(sort: Desc)])
  @@map("vendor_payouts")
}
