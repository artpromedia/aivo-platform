// ══════════════════════════════════════════════════════════════════════════════
// BILLING SERVICE - PRISMA SCHEMA
// ══════════════════════════════════════════════════════════════════════════════
// 
// This schema defines the billing & subscription data model for the Aivo platform.
// It supports:
//   - Parent (consumer) subscriptions with base + add-on modules
//   - District contracts with seat-based licensing
//   - Payment provider abstraction (Stripe, manual invoice, etc.)
//   - Trials, proration, and invoice management
//
// ══════════════════════════════════════════════════════════════════════════════

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ══════════════════════════════════════════════════════════════════════════════
// ENUMS
// ══════════════════════════════════════════════════════════════════════════════

/// Type of billing account - determines business rules and UI flows
enum BillingAccountType {
  PARENT_CONSUMER   // Individual parent paying for their children
  DISTRICT          // School district with seat-based licensing
  PLATFORM_INTERNAL // Internal/free accounts (e.g., demo, testing)
}

/// Current status of a subscription
enum SubscriptionStatus {
  IN_TRIAL    // Active trial period, no charges yet
  ACTIVE      // Paid and in good standing
  PAST_DUE    // Payment failed, grace period
  CANCELED    // User canceled, may have access until period end
  EXPIRED     // Subscription ended, no access
}

/// Type of plan - determines pricing logic and features
enum PlanType {
  PARENT_BASE     // Core ELA + Math for parent subscribers
  PARENT_ADDON    // Add-on modules (SEL, Speech, Science, etc.)
  DISTRICT_BASE   // Base district licensing
  DISTRICT_ADDON  // District add-on modules
}

/// Billing frequency
enum BillingPeriod {
  MONTHLY
  YEARLY
}

/// Payment provider for processing payments
enum PaymentProvider {
  STRIPE          // Stripe payment processor
  MANUAL_INVOICE  // Manual invoicing (for districts)
  TEST_FAKE       // Test/fake provider for development
}

/// Billing period for contract pricing and line items
enum ContractBillingPeriod {
  ANNUAL      // Billed yearly
  MULTI_YEAR  // Upfront multi-year (e.g., 3-year deal)
  ONE_TIME    // One-time charge (setup fees, etc.)
}

/// Contract status lifecycle
enum ContractStatus {
  DRAFT       // Being negotiated, not yet active
  PENDING     // Signed but awaiting start date
  ACTIVE      // Currently in effect
  SUSPENDED   // Temporarily suspended (e.g., payment issues)
  EXPIRED     // Past end date, naturally ended
  CANCELLED   // Terminated before end date
  RENEWED     // Replaced by a new contract
}

/// Payment type for contracts
enum ContractPaymentType {
  INVOICE     // Net terms invoice (typical for districts)
  CARD        // Credit card payment
  HYBRID      // Mix of invoice and card
  PO          // Purchase order based
}

/// Invoice status
enum InvoiceStatus {
  DRAFT         // Being prepared, not yet finalized
  OPEN          // Finalized and awaiting payment
  PAID          // Successfully paid
  VOID          // Canceled/voided
  UNCOLLECTIBLE // Payment failed, written off
}

// ══════════════════════════════════════════════════════════════════════════════
// BILLING ACCOUNTS
// ══════════════════════════════════════════════════════════════════════════════
// 
// A billing account represents a paying entity - either a parent or a district.
// It links to a tenant and optionally to an owner user.
//

model BillingAccount {
  id                    String              @id @default(uuid()) @db.Uuid
  
  /// Reference to the tenant this billing account belongs to
  tenantId              String              @db.Uuid
  
  /// Type of billing account
  accountType           BillingAccountType
  
  /// Owner user (for parent accounts). Null for district/internal accounts.
  ownerUserId           String?             @db.Uuid
  
  /// Display name for the account (e.g., "Smith Family" or "North Valley District")
  displayName           String
  
  /// Payment provider used for this account
  provider              PaymentProvider     @default(STRIPE)
  
  /// External customer ID in the payment provider (e.g., Stripe customer ID)
  providerCustomerId    String?
  
  /// Default currency for this account
  defaultCurrency       String              @default("USD") @db.VarChar(3)
  
  /// Email for billing notifications
  billingEmail          String?
  
  /// Additional metadata (e.g., tax exemption info, contract terms)
  metadataJson          Json?
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Relations
  subscriptions         Subscription[]
  billingInstruments    BillingInstrument[]
  invoices              Invoice[]
  districtProfile       DistrictBillingProfile?
  
  @@index([tenantId, accountType])
  @@index([providerCustomerId])
  @@map("billing_accounts")
}

// ══════════════════════════════════════════════════════════════════════════════
// PLANS
// ══════════════════════════════════════════════════════════════════════════════
//
// Plans define what's available for purchase. Plans are reusable templates
// that subscriptions reference. They include pricing and feature definitions.
//

model Plan {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Unique SKU identifier (e.g., "PARENT_BASE", "ADDON_SEL", "DISTRICT_BASE_1Y")
  sku             String        @unique
  
  /// Type of plan
  planType        PlanType
  
  /// Human-readable name
  name            String
  
  /// Description for display
  description     String?
  
  /// Price in cents per unit per billing period
  unitPriceCents  Int
  
  /// Billing frequency
  billingPeriod   BillingPeriod @default(MONTHLY)
  
  /// Whether this plan is currently available for new subscriptions
  isActive        Boolean       @default(true)
  
  /// Trial duration in days (0 = no trial)
  trialDays       Int           @default(0)
  
  /// Metadata: features, limits, modules included, etc.
  /// Example: { "modules": ["ELA", "MATH"], "maxLearners": 5 }
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  subscriptions       Subscription[]
  subscriptionItems   SubscriptionItem[]
  
  @@index([planType, isActive])
  @@map("plans")
}

// ══════════════════════════════════════════════════════════════════════════════
// SUBSCRIPTIONS
// ══════════════════════════════════════════════════════════════════════════════
//
// A subscription represents an active (or past) agreement between a billing
// account and a plan. Tracks status, billing periods, and trial information.
//

model Subscription {
  id                      String              @id @default(uuid()) @db.Uuid
  
  /// The billing account that owns this subscription
  billingAccountId        String              @db.Uuid
  
  /// The plan this subscription is based on
  planId                  String              @db.Uuid
  
  /// Current subscription status
  status                  SubscriptionStatus  @default(IN_TRIAL)
  
  /// Quantity: # of children (parent) or seats/learners (district)
  quantity                Int                 @default(1)
  
  /// Trial period start (null if no trial)
  trialStartAt            DateTime?           @db.Timestamptz
  
  /// Trial period end (null if no trial)
  trialEndAt              DateTime?           @db.Timestamptz
  
  /// Current billing period start
  currentPeriodStart      DateTime            @db.Timestamptz
  
  /// Current billing period end
  currentPeriodEnd        DateTime            @db.Timestamptz
  
  /// Whether subscription will be canceled at period end
  cancelAtPeriodEnd       Boolean             @default(false)
  
  /// Date when subscription was canceled (null if not canceled)
  canceledAt              DateTime?           @db.Timestamptz
  
  /// Date when subscription ended/will end
  endedAt                 DateTime?           @db.Timestamptz
  
  /// External subscription ID in payment provider
  providerSubscriptionId  String?
  
  /// Metadata: specific modules unlocked, contract terms, etc.
  /// Example: { "modules": ["ELA", "MATH", "SEL"], "contractNumber": "DST-2024-001" }
  metadataJson            Json?
  
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt
  
  // Relations
  billingAccount          BillingAccount      @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  plan                    Plan                @relation(fields: [planId], references: [id])
  subscriptionItems       SubscriptionItem[]
  invoiceLineItems        InvoiceLineItem[]
  
  @@index([billingAccountId, status])
  @@index([providerSubscriptionId])
  @@index([status, currentPeriodEnd])
  @@map("subscriptions")
}

// ══════════════════════════════════════════════════════════════════════════════
// SUBSCRIPTION ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Line items within a subscription for itemized billing.
// Useful when a single subscription includes multiple plans (e.g., base + add-ons)
// or when tracking per-learner allocation.
//

model SubscriptionItem {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Parent subscription
  subscriptionId  String        @db.Uuid
  
  /// The plan/product for this line item
  planId          String        @db.Uuid
  
  /// SKU reference (denormalized for query convenience)
  sku             String
  
  /// Quantity of this item
  quantity        Int           @default(1)
  
  /// Optional: Specific learner this item is allocated to
  learnerId       String?       @db.Uuid
  
  /// Metadata: module-specific settings, etc.
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  plan            Plan          @relation(fields: [planId], references: [id])
  
  @@index([subscriptionId])
  @@index([learnerId])
  @@map("subscription_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// BILLING INSTRUMENTS (Payment Methods)
// ══════════════════════════════════════════════════════════════════════════════
//
// Stored payment methods. Only tokenized references are stored - never raw card data.
//

model BillingInstrument {
  id                        String          @id @default(uuid()) @db.Uuid
  
  /// The billing account this payment method belongs to
  billingAccountId          String          @db.Uuid
  
  /// External payment method ID in payment provider (e.g., Stripe pm_xxx)
  providerPaymentMethodId   String
  
  /// Card brand (e.g., "visa", "mastercard", "amex")
  brand                     String?
  
  /// Last 4 digits of card number
  last4                     String?         @db.VarChar(4)
  
  /// Expiry month (1-12)
  expiryMonth               Int?            @db.SmallInt
  
  /// Expiry year (e.g., 2025)
  expiryYear                Int?            @db.SmallInt
  
  /// Whether this is the default payment method for the account
  isDefault                 Boolean         @default(false)
  
  /// Type of instrument (card, bank_account, etc.)
  instrumentType            String          @default("card")
  
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt
  
  // Relations
  billingAccount            BillingAccount  @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  
  @@index([billingAccountId])
  @@index([providerPaymentMethodId])
  @@map("billing_instruments")
}

// ══════════════════════════════════════════════════════════════════════════════
// INVOICES
// ══════════════════════════════════════════════════════════════════════════════
//
// Invoices track charges and payments. They can be generated automatically
// from subscriptions or manually for districts.
//

model Invoice {
  id                  String          @id @default(uuid()) @db.Uuid
  
  /// Billing account this invoice belongs to
  billingAccountId    String          @db.Uuid
  
  /// External invoice ID in payment provider
  providerInvoiceId   String?
  
  /// Human-readable invoice number (e.g., "INV-2024-00001")
  invoiceNumber       String?         @unique
  
  /// Total amount due in cents
  amountDueCents      Int
  
  /// Amount already paid in cents
  amountPaidCents     Int             @default(0)
  
  /// Currency code
  currency            String          @default("USD") @db.VarChar(3)
  
  /// Invoice status
  status              InvoiceStatus   @default(DRAFT)
  
  /// Billing period start this invoice covers
  periodStart         DateTime        @db.Timestamptz
  
  /// Billing period end this invoice covers
  periodEnd           DateTime        @db.Timestamptz
  
  /// When the invoice was finalized and sent
  issuedAt            DateTime?       @db.Timestamptz
  
  /// Payment due date
  dueAt               DateTime?       @db.Timestamptz
  
  /// When payment was received
  paidAt              DateTime?       @db.Timestamptz
  
  /// PDF URL or path
  pdfUrl              String?
  
  /// Metadata: proration info, adjustments, notes, etc.
  metadataJson        Json?
  
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  
  // Relations
  billingAccount      BillingAccount  @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  lineItems           InvoiceLineItem[]
  
  @@index([billingAccountId, issuedAt(sort: Desc)])
  @@index([status])
  @@index([providerInvoiceId])
  @@map("invoices")
}

// ══════════════════════════════════════════════════════════════════════════════
// INVOICE LINE ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual line items on an invoice. Can represent subscription charges,
// prorations, one-time charges, credits, etc.
//

model InvoiceLineItem {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Parent invoice
  invoiceId       String        @db.Uuid
  
  /// Optional: linked subscription for recurring charges
  subscriptionId  String?       @db.Uuid
  
  /// Description of the charge
  description     String
  
  /// Unit price in cents
  unitPriceCents  Int
  
  /// Quantity
  quantity        Int           @default(1)
  
  /// Total amount in cents (unitPriceCents * quantity, or custom for prorations)
  amountCents     Int
  
  /// Type of line item
  lineItemType    String        @default("subscription") // subscription, proration, credit, one_time
  
  /// Metadata: proration details, period adjustments, etc.
  /// Example: { "prorationFactor": 0.5, "originalPeriodStart": "...", "reason": "mid-cycle upgrade" }
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  
  // Relations
  invoice         Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  subscription    Subscription? @relation(fields: [subscriptionId], references: [id])
  
  @@index([invoiceId])
  @@index([subscriptionId])
  @@map("invoice_line_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// USAGE RECORDS (for metered billing - future)
// ══════════════════════════════════════════════════════════════════════════════
//
// Tracks usage for metered billing scenarios (e.g., API calls, extra learners).
// Included for future extensibility but not required for initial implementation.
//

model UsageRecord {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Subscription this usage is for
  subscriptionId  String        @db.Uuid
  
  /// Metric being tracked (e.g., "learner_count", "api_calls", "storage_gb")
  metric          String
  
  /// Quantity of usage
  quantity        Int
  
  /// Timestamp of the usage
  timestamp       DateTime      @db.Timestamptz
  
  /// Whether this has been invoiced
  invoiced        Boolean       @default(false)
  
  /// Metadata: additional context
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  
  @@index([subscriptionId, metric, timestamp])
  @@index([invoiced])
  @@map("usage_records")
}

// ══════════════════════════════════════════════════════════════════════════════
// PAYMENT EVENTS (Audit Log)
// ══════════════════════════════════════════════════════════════════════════════
//
// Tracks all payment-related events from external providers (Stripe webhooks,
// etc.) for auditing, debugging, and reconciliation purposes.
//

model PaymentEvent {
  id                  String          @id @default(uuid()) @db.Uuid
  
  /// Payment provider that sent the event
  provider            PaymentProvider @default(STRIPE)
  
  /// Event type from the provider (e.g., "invoice.paid", "customer.subscription.deleted")
  eventType           String
  
  /// Provider's unique event ID for deduplication
  providerEventId     String          @unique
  
  /// Associated billing account (if identifiable)
  billingAccountId    String?         @db.Uuid
  
  /// Associated subscription (if identifiable)
  subscriptionId      String?         @db.Uuid
  
  /// Associated invoice (if identifiable)
  invoiceId           String?         @db.Uuid
  
  /// Raw event payload from the provider
  payload             Json
  
  /// When we finished processing this event
  processedAt         DateTime?       @db.Timestamptz
  
  /// Error message if processing failed
  error               String?
  
  createdAt           DateTime        @default(now())
  
  @@index([provider, eventType])
  @@index([billingAccountId])
  @@index([providerEventId])
  @@index([createdAt])
  @@map("payment_events")
}

// ══════════════════════════════════════════════════════════════════════════════
// PRODUCTS / SKUs
// ══════════════════════════════════════════════════════════════════════════════
//
// Products represent purchasable items in the catalog. SKUs are modeled as
// database rows for flexibility, but core SKUs are seeded on deployment.
//

model Product {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Unique SKU identifier (e.g., "SEAT_K5", "ADDON_SEL")
  sku             String        @unique
  
  /// Human-readable product name
  name            String
  
  /// Product description
  description     String?
  
  /// Product category for filtering/grouping
  category        String        // e.g., "BASE", "SEAT", "ADDON"
  
  /// Whether this product is currently available
  isActive        Boolean       @default(true)
  
  /// Unit of measure (e.g., "seat", "tenant", "module")
  unitOfMeasure   String        @default("seat")
  
  /// Sort order for display
  sortOrder       Int           @default(0)
  
  /// Metadata: features included, grade bands, module details
  /// Example: { "gradeBands": ["K-5"], "modules": ["ELA", "MATH"] }
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  priceBookEntries  PriceBookEntry[]
  contractLineItems ContractLineItem[]
  
  @@index([category, isActive])
  @@map("products")
}

// ══════════════════════════════════════════════════════════════════════════════
// PRICE BOOKS
// ══════════════════════════════════════════════════════════════════════════════
//
// Price books define standard pricing for products. Multiple price books
// support regional pricing, customer segments, or promotional pricing.
//

model PriceBook {
  id            String        @id @default(uuid()) @db.Uuid
  
  /// Price book name (e.g., "US K-12 Standard 2025", "Texas State Contract")
  name          String
  
  /// Description of this price book
  description   String?
  
  /// Currency for all entries in this price book
  currency      String        @default("USD") @db.VarChar(3)
  
  /// Whether this is the default price book for new contracts
  isDefault     Boolean       @default(false)
  
  /// Whether this price book is currently active
  isActive      Boolean       @default(true)
  
  /// Effective date - when this price book becomes valid
  effectiveFrom DateTime      @default(now()) @db.Date
  
  /// Expiration date - when this price book expires (null = no expiry)
  effectiveUntil DateTime?    @db.Date
  
  /// Metadata: region restrictions, customer segment, notes
  metadataJson  Json?
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  // Relations
  entries       PriceBookEntry[]
  contracts     Contract[]
  
  @@index([isDefault, isActive])
  @@map("price_books")
}

// ══════════════════════════════════════════════════════════════════════════════
// PRICE BOOK ENTRIES
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual pricing entries within a price book. Each entry defines the
// list price for a specific SKU at a specific billing period.
//

model PriceBookEntry {
  id              String                @id @default(uuid()) @db.Uuid
  
  /// Parent price book
  priceBookId     String                @db.Uuid
  
  /// Product this entry prices
  productId       String                @db.Uuid
  
  /// SKU (denormalized for query convenience)
  sku             String
  
  /// Unit price (in major currency units, e.g., dollars not cents)
  unitPrice       Decimal               @db.Decimal(12, 2)
  
  /// Billing period this price applies to
  billingPeriod   ContractBillingPeriod @default(ANNUAL)
  
  /// Minimum quantity for this price (for tiered pricing)
  minQuantity     Int                   @default(1)
  
  /// Maximum quantity for this price tier (null = unlimited)
  maxQuantity     Int?
  
  /// Metadata: volume discounts, bundling rules, etc.
  /// Example: { "volumeTiers": [{ "minSeats": 1000, "discountPct": 5 }] }
  metadataJson    Json?
  
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  
  // Relations
  priceBook       PriceBook             @relation(fields: [priceBookId], references: [id], onDelete: Cascade)
  product         Product               @relation(fields: [productId], references: [id])
  
  @@unique([priceBookId, sku, billingPeriod, minQuantity])
  @@index([priceBookId])
  @@index([sku])
  @@map("price_book_entries")
}

// ══════════════════════════════════════════════════════════════════════════════
// DISTRICT BILLING PROFILES
// ══════════════════════════════════════════════════════════════════════════════
//
// Extended billing account information specific to district customers.
// Links to the existing BillingAccount model.
//

model DistrictBillingProfile {
  id                    String        @id @default(uuid()) @db.Uuid
  
  /// Link to the base billing account
  billingAccountId      String        @unique @db.Uuid
  
  /// Primary tenant this billing profile serves
  tenantId              String        @db.Uuid
  
  /// Billing contact name
  billingContactName    String
  
  /// Billing contact email
  billingContactEmail   String
  
  /// Billing contact phone
  billingContactPhone   String?
  
  /// Billing address as structured JSON
  /// { "line1": "...", "line2": "...", "city": "...", "state": "...", "zip": "...", "country": "..." }
  billingAddressJson    Json
  
  /// Payment terms in days (e.g., Net 30 = 30)
  paymentTermsDays      Int           @default(30)
  
  /// Tax exempt status
  isTaxExempt           Boolean       @default(true)
  
  /// Tax exemption certificate number
  taxExemptionNumber    String?
  
  /// Purchase order requirements
  requiresPO            Boolean       @default(true)
  
  /// Credit limit in cents (for invoice-based billing)
  creditLimitCents      Int?
  
  /// Metadata: additional district info, state contracts, etc.
  metadataJson          Json?
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  
  // Relations
  billingAccount        BillingAccount @relation(fields: [billingAccountId], references: [id])
  contracts             Contract[]
  
  @@index([tenantId])
  @@map("district_billing_profiles")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Contracts represent formal agreements with district customers. They define
// what products/seats are licensed, pricing terms, and contract duration.
//

model Contract {
  id                    String                @id @default(uuid()) @db.Uuid
  
  /// District billing profile this contract belongs to
  billingProfileId      String                @db.Uuid
  
  /// Tenant receiving entitlements from this contract
  tenantId              String                @db.Uuid
  
  /// Human-readable contract number (e.g., "DST-2025-00042")
  contractNumber        String                @unique
  
  /// Contract name/title
  name                  String?
  
  /// Contract start date
  startDate             DateTime              @db.Date
  
  /// Contract end date
  endDate               DateTime              @db.Date
  
  /// Current contract status
  status                ContractStatus        @default(DRAFT)
  
  /// Price book used for this contract
  priceBookId           String                @db.Uuid
  
  /// Customer's purchase order number
  poNumber              String?
  
  /// Payment type
  paymentType           ContractPaymentType   @default(INVOICE)
  
  /// Total contract value in cents (calculated from line items)
  totalValueCents       BigInt                @default(0)
  
  /// Currency
  currency              String                @default("USD") @db.VarChar(3)
  
  /// Signed date
  signedAt              DateTime?             @db.Timestamptz
  
  /// User who created the contract
  createdBy             String?               @db.Uuid
  
  /// Auto-renewal settings
  autoRenewal           Boolean               @default(false)
  
  /// Renewal notice days (days before end date to send renewal notice)
  renewalNoticeDays     Int                   @default(90)
  
  /// Parent contract (for renewals/amendments)
  parentContractId      String?               @db.Uuid
  
  /// Metadata: custom terms, legal notes, amendment history
  /// Example: { "legalTerms": "...", "specialConditions": [...] }
  metadataJson          Json?
  
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  // Relations
  billingProfile        DistrictBillingProfile @relation(fields: [billingProfileId], references: [id])
  priceBook             PriceBook              @relation(fields: [priceBookId], references: [id])
  parentContract        Contract?              @relation("ContractRenewals", fields: [parentContractId], references: [id])
  renewedContracts      Contract[]             @relation("ContractRenewals")
  lineItems             ContractLineItem[]
  invoiceSchedules      ContractInvoiceSchedule[]
  entitlements          ContractEntitlement[]
  seatEntitlements      SeatEntitlement[]
  
  @@index([billingProfileId, status])
  @@index([tenantId, status])
  @@index([status, endDate])
  @@index([contractNumber])
  @@map("contracts")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT LINE ITEMS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual line items within a contract. Each line item represents a
// specific product (SKU) with quantity, pricing, and any negotiated discounts.
//

model ContractLineItem {
  id                  String                @id @default(uuid()) @db.Uuid
  
  /// Parent contract
  contractId          String                @db.Uuid
  
  /// Product being purchased
  productId           String                @db.Uuid
  
  /// SKU (denormalized)
  sku                 String
  
  /// Line item description (can override product description)
  description         String
  
  /// Billing period for this line item
  billingPeriod       ContractBillingPeriod @default(ANNUAL)
  
  /// Committed quantity (seats, units, etc.)
  quantityCommitted   Int
  
  /// Minimum quantity (for use-based billing)
  quantityMinimum     Int?
  
  /// Maximum quantity (cap)
  quantityMaximum     Int?
  
  /// List price per unit (from price book)
  listPricePerUnit    Decimal               @db.Decimal(12, 2)
  
  /// Final negotiated price per unit
  unitPrice           Decimal               @db.Decimal(12, 2)
  
  /// Discount percentage applied
  discountPercent     Decimal?              @db.Decimal(5, 2)
  
  /// Discount reason (for audit trail)
  discountReason      String?
  
  /// Total line item value in cents
  totalValueCents     BigInt                @default(0)
  
  /// Start date (if different from contract start)
  startDate           DateTime?             @db.Date
  
  /// End date (if different from contract end)
  endDate             DateTime?             @db.Date
  
  /// Metadata: grade bands, school allocations, etc.
  /// Example: { "gradeBands": ["K-5"], "schoolAllocations": { "school-uuid": 500 } }
  metadataJson        Json?
  
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  
  // Relations
  contract            Contract              @relation(fields: [contractId], references: [id], onDelete: Cascade)
  product             Product               @relation(fields: [productId], references: [id])
  allocations         ContractAllocation[]
  
  @@index([contractId, sku])
  @@index([sku])
  @@map("contract_line_items")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT ALLOCATIONS
// ══════════════════════════════════════════════════════════════════════════════
//
// Allocations distribute contract line items across schools within a district.
// This enables tracking seat usage and entitlements at the school level.
//

model ContractAllocation {
  id                String              @id @default(uuid()) @db.Uuid
  
  /// Parent line item
  lineItemId        String              @db.Uuid
  
  /// School receiving the allocation
  schoolId          String              @db.Uuid
  
  /// Quantity allocated to this school
  quantityAllocated Int
  
  /// Quantity currently used
  quantityUsed      Int                 @default(0)
  
  /// Metadata: additional allocation details
  metadataJson      Json?
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  // Relations
  lineItem          ContractLineItem    @relation(fields: [lineItemId], references: [id], onDelete: Cascade)
  
  @@unique([lineItemId, schoolId])
  @@index([schoolId])
  @@map("contract_allocations")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT ENTITLEMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Entitlements represent the actual features/access granted by a contract.
// These are the runtime permissions checked by the product.
//

model ContractEntitlement {
  id              String        @id @default(uuid()) @db.Uuid
  
  /// Parent contract
  contractId      String        @db.Uuid
  
  /// Tenant receiving the entitlement
  tenantId        String        @db.Uuid
  
  /// Feature/module being entitled (e.g., "MODULE_SEL", "GRADE_K5")
  featureKey      String
  
  /// Whether this entitlement is currently active
  isActive        Boolean       @default(true)
  
  /// Quantity/limit (e.g., seat count)
  quantity        Int?
  
  /// Effective start date
  startDate       DateTime      @db.Date
  
  /// Effective end date
  endDate         DateTime      @db.Date
  
  /// Metadata: feature-specific config
  metadataJson    Json?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  contract        Contract      @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  @@unique([contractId, featureKey])
  @@index([tenantId, featureKey, isActive])
  @@index([tenantId, endDate])
  @@map("contract_entitlements")
}

// ══════════════════════════════════════════════════════════════════════════════
// SEAT ENTITLEMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Seat entitlements are derived from contract line items for seat-based SKUs.
// They track seat allocation and usage for each tenant/grade band combination.
// This enables runtime enforcement of seat limits.
//

/// Grade band for seat licensing
enum GradeBand {
  K_2       // Kindergarten through 2nd grade
  G3_5      // Grades 3-5
  G6_8      // Grades 6-8
  G9_12     // Grades 9-12
  TEACHER   // Teacher licenses
  ALL       // All grades (for add-on modules)
}

/// Enforcement mode for seat caps
enum SeatCapEnforcement {
  SOFT      // Allow overage with warnings
  HARD      // Block new assignments when limit reached
  UNLIMITED // No enforcement (rare)
}

model SeatEntitlement {
  id                    String              @id @default(uuid()) @db.Uuid
  
  /// Tenant this entitlement belongs to
  tenantId              String              @db.Uuid
  
  /// Parent contract
  contractId            String              @db.Uuid
  
  /// Contract line item this was derived from
  lineItemId            String              @db.Uuid
  
  /// SKU for this entitlement (e.g., "SEAT_K5", "SEAT_6_8")
  sku                   String
  
  /// Grade band (derived from SKU)
  gradeBand             GradeBand
  
  /// Total committed seats from contract
  quantityCommitted     Int
  
  /// Currently allocated/assigned seats
  quantityAllocated     Int                 @default(0)
  
  /// Whether overage is allowed
  overageAllowed        Boolean             @default(false)
  
  /// Maximum allowed overage (null = unlimited if allowed)
  overageLimit          Int?
  
  /// Current overage count (seats over committed amount)
  overageCount          Int                 @default(0)
  
  /// Enforcement mode for this entitlement
  enforcement           SeatCapEnforcement  @default(SOFT)
  
  /// Effective start date
  startDate             DateTime            @db.Date
  
  /// Effective end date
  endDate               DateTime            @db.Date
  
  /// Whether this entitlement is currently active
  isActive              Boolean             @default(true)
  
  /// Metadata: school allocations, usage history, etc.
  metadataJson          Json?
  
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Relations
  contract              Contract            @relation(fields: [contractId], references: [id], onDelete: Cascade)
  licenseAssignments    LicenseAssignment[]
  
  @@unique([tenantId, contractId, sku])
  @@index([tenantId, gradeBand, isActive])
  @@index([contractId])
  @@index([tenantId, endDate])
  @@map("seat_entitlements")
}

// ══════════════════════════════════════════════════════════════════════════════
// LICENSE ASSIGNMENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Individual seat license assignments to learners (or teachers for add-ons).
// Tracks the lifecycle of each assigned seat for audit and compliance.
//

/// Status of a license assignment
enum LicenseAssignmentStatus {
  ACTIVE      // Currently assigned and valid
  REVOKED     // Manually revoked (e.g., learner transferred out)
  EXPIRED     // Contract/entitlement expired
  TRANSFERRED // Transferred to different grade band
}

model LicenseAssignment {
  id                  String                    @id @default(uuid()) @db.Uuid
  
  /// Tenant this assignment belongs to
  tenantId            String                    @db.Uuid
  
  /// Parent seat entitlement
  entitlementId       String                    @db.Uuid
  
  /// Learner receiving this license (null for add-on module entitlements)
  learnerId           String?                   @db.Uuid
  
  /// Teacher receiving this license (for teacher-specific add-ons)
  teacherId           String?                   @db.Uuid
  
  /// SKU for this assignment
  sku                 String
  
  /// Grade band at time of assignment
  gradeBand           GradeBand
  
  /// School ID (for school-level tracking)
  schoolId            String?                   @db.Uuid
  
  /// Assignment status
  status              LicenseAssignmentStatus   @default(ACTIVE)
  
  /// Whether this was an overage assignment
  isOverage           Boolean                   @default(false)
  
  /// When the license was assigned
  assignedAt          DateTime                  @default(now()) @db.Timestamptz
  
  /// When the license was revoked (null if still active)
  revokedAt           DateTime?                 @db.Timestamptz
  
  /// Reason for revocation (if revoked)
  revokedReason       String?
  
  /// User who made the assignment (for audit)
  assignedBy          String?                   @db.Uuid
  
  /// User who revoked (for audit)
  revokedBy           String?                   @db.Uuid
  
  /// Previous assignment ID (for grade band transfers)
  previousAssignmentId String?                  @db.Uuid
  
  /// Metadata: assignment context, source system, etc.
  metadataJson        Json?
  
  createdAt           DateTime                  @default(now())
  updatedAt           DateTime                  @updatedAt
  
  // Relations
  entitlement         SeatEntitlement           @relation(fields: [entitlementId], references: [id], onDelete: Cascade)
  previousAssignment  LicenseAssignment?        @relation("LicenseTransfers", fields: [previousAssignmentId], references: [id])
  transferredTo       LicenseAssignment[]       @relation("LicenseTransfers")
  
  @@index([tenantId, learnerId, status])
  @@index([tenantId, gradeBand, status])
  @@index([entitlementId, status])
  @@index([schoolId, status])
  @@index([learnerId])
  @@index([teacherId])
  @@map("license_assignments")
}

// ══════════════════════════════════════════════════════════════════════════════
// LICENSE EVENTS
// ══════════════════════════════════════════════════════════════════════════════
//
// Audit log for all licensing events - assignments, revocations, overages, etc.
// Used for compliance reporting and troubleshooting.
//

/// Type of license event
enum LicenseEventType {
  ENTITLEMENT_CREATED     // New entitlement synced from contract
  ENTITLEMENT_UPDATED     // Entitlement quantity changed
  ENTITLEMENT_EXPIRED     // Entitlement reached end date
  LICENSE_ASSIGNED        // Seat assigned to learner
  LICENSE_REVOKED         // Seat revoked from learner
  LICENSE_TRANSFERRED     // Seat moved to different grade band
  OVERAGE_WARNING         // Soft cap warning triggered
  OVERAGE_BLOCKED         // Hard cap blocked assignment
  CAP_ADJUSTED            // Admin adjusted cap settings
}

model LicenseEvent {
  id                String            @id @default(uuid()) @db.Uuid
  
  /// Tenant this event belongs to
  tenantId          String            @db.Uuid
  
  /// Event type
  eventType         LicenseEventType
  
  /// Related entitlement (if applicable)
  entitlementId     String?           @db.Uuid
  
  /// Related license assignment (if applicable)
  assignmentId      String?           @db.Uuid
  
  /// Related learner (if applicable)
  learnerId         String?           @db.Uuid
  
  /// User who triggered the event (system if automated)
  actorId           String?           @db.Uuid
  
  /// Actor type
  actorType         String            @default("SYSTEM") // SYSTEM, USER, API
  
  /// Event description
  description       String
  
  /// Previous state (for changes)
  previousValue     Json?
  
  /// New state (for changes)
  newValue          Json?
  
  /// Additional event context
  metadataJson      Json?
  
  createdAt         DateTime          @default(now()) @db.Timestamptz
  
  @@index([tenantId, eventType])
  @@index([tenantId, createdAt])
  @@index([entitlementId])
  @@index([assignmentId])
  @@index([learnerId])
  @@map("license_events")
}

// ══════════════════════════════════════════════════════════════════════════════
// CONTRACT INVOICE SCHEDULE
// ══════════════════════════════════════════════════════════════════════════════
//
// Defines the invoicing schedule for a contract. Supports various billing
// patterns (annual upfront, quarterly, milestone-based, etc.).
//

model ContractInvoiceSchedule {
  id                String          @id @default(uuid()) @db.Uuid
  
  /// Parent contract
  contractId        String          @db.Uuid
  
  /// Scheduled invoice date
  scheduledDate     DateTime        @db.Date
  
  /// Invoice amount in cents
  amountCents       BigInt
  
  /// Description/milestone name
  description       String?
  
  /// Invoice ID (once generated)
  invoiceId         String?         @db.Uuid
  
  /// Status of this schedule item
  status            String          @default("PENDING") // PENDING, INVOICED, PAID, CANCELLED
  
  /// Metadata: period covered, line item breakdown, etc.
  metadataJson      Json?
  
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relations
  contract          Contract        @relation(fields: [contractId], references: [id], onDelete: Cascade)
  
  @@index([contractId, status])
  @@index([scheduledDate, status])
  @@map("contract_invoice_schedules")
}
