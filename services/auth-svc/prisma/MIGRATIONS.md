# Database Migration Guidelines

## Overview

This document outlines best practices for database migrations in the AIVO Auth Service. Following these guidelines ensures safe, reversible, and zero-downtime deployments.

## Table of Contents

- [Creating Migrations](#creating-migrations)
- [Naming Conventions](#naming-conventions)
- [Zero-Downtime Migrations](#zero-downtime-migrations)
- [Rollback Strategy](#rollback-strategy)
- [Data Migrations](#data-migrations)
- [Pre-Production Checklist](#pre-production-checklist)

---

## Creating Migrations

### Development Workflow

1. **Make changes to `schema.prisma`**
   ```bash
   # Edit prisma/schema.prisma
   ```

2. **Generate and apply migration**
   ```bash
   npm run db:migrate:dev -- --name descriptive_name
   ```

3. **Review the generated SQL**
   ```bash
   # Check prisma/migrations/[timestamp]_descriptive_name/migration.sql
   ```

4. **Commit both files**
   ```bash
   git add prisma/schema.prisma prisma/migrations/
   git commit -m "feat(db): add descriptive_name migration"
   ```

### Creating Without Applying

To review SQL before applying:

```bash
npm run db:migrate:create -- --name my_migration
# Review prisma/migrations/[timestamp]_my_migration/migration.sql
# Then apply:
npm run db:migrate:dev
```

---

## Naming Conventions

Use **snake_case** for migration names. Be descriptive about what the migration does.

### Schema Changes

| Pattern | Example |
|---------|---------|
| Adding a table | `create_audit_log_table` |
| Adding a column | `add_user_mfa_enabled_column` |
| Adding an index | `add_user_email_index` |
| Modifying a column | `change_session_expires_to_timestamp` |
| Dropping a column | `remove_deprecated_user_legacy_id` |
| Adding a relation | `add_user_to_organization_relation` |

### Data Migrations

| Pattern | Example |
|---------|---------|
| Backfilling data | `backfill_user_display_names` |
| Migrating values | `migrate_role_ids_to_enums` |
| Cleaning up | `cleanup_orphaned_sessions` |

---

## Zero-Downtime Migrations

For production deployments, **all migrations must be backward compatible** with the currently running code.

### ✅ Safe Operations (No Coordination Required)

| Operation | Notes |
|-----------|-------|
| Adding a nullable column | No default required |
| Adding a column with default | Prisma handles this |
| Adding a new table | No existing code references it |
| Adding an index | Use `CREATE INDEX CONCURRENTLY` for large tables |
| Renaming an index | Safe, transparent to application |

### ⚠️ Multi-Phase Operations (Requires Coordination)

These operations require multiple deployments:

#### Renaming a Column

**Phase 1: Add new column**
```sql
ALTER TABLE "User" ADD COLUMN "displayName" TEXT;
```

**Phase 2: Deploy code that writes to both columns**
```typescript
// Write to both old and new
await prisma.user.update({
  where: { id },
  data: { name: value, displayName: value }
});
```

**Phase 3: Backfill data**
```sql
UPDATE "User" SET "displayName" = "name" WHERE "displayName" IS NULL;
```

**Phase 4: Deploy code that reads from new column only**

**Phase 5: Drop old column**
```sql
ALTER TABLE "User" DROP COLUMN "name";
```

#### Changing Column Type

1. Add new column with new type
2. Deploy code to write to both
3. Backfill existing data with type conversion
4. Deploy code to read from new column
5. Drop old column

### ❌ Dangerous Operations (Avoid in Production)

| Operation | Why Dangerous | Alternative |
|-----------|---------------|-------------|
| Dropping a column | App may still reference it | Multi-phase approach |
| Renaming a column | Breaks running instances | Multi-phase approach |
| Adding NOT NULL without default | Fails if data exists | Add nullable first, backfill, then add constraint |
| Changing column type | May lose data | Multi-phase with new column |
| Dropping a table | Data loss | Archive first, verify no references |

---

## Rollback Strategy

> ⚠️ **Prisma does not support automatic rollbacks.** You must plan for manual rollbacks.

### For Each Migration

1. **Create a corresponding `down.sql`** (manual)
   ```
   prisma/migrations/
   └── 20240101000000_add_user_mfa/
       ├── migration.sql    # Generated by Prisma
       └── down.sql         # Created manually
   ```

2. **Document rollback steps** in the migration
   ```sql
   -- migration.sql
   -- Rollback: ALTER TABLE "User" DROP COLUMN "mfaEnabled";
   ALTER TABLE "User" ADD COLUMN "mfaEnabled" BOOLEAN DEFAULT false;
   ```

### Rollback Procedure

1. **Stop the deployment** immediately
2. **Rollback code** to previous version
3. **Apply rollback SQL** manually:
   ```bash
   psql $DATABASE_URL -f prisma/migrations/[migration]/down.sql
   ```
4. **Mark migration as rolled back** in `_prisma_migrations` table:
   ```sql
   DELETE FROM "_prisma_migrations" WHERE migration_name = 'migration_name';
   ```

### Testing Rollbacks

**Always test rollbacks in staging before production:**

```bash
# Apply migration
npm run db:migrate:deploy

# Test rollback
psql $DATABASE_URL -f prisma/migrations/[migration]/down.sql

# Verify schema matches expected state
npm run db:migrate:status
```

---

## Data Migrations

For large data changes, use dedicated data migration scripts instead of SQL in schema migrations.

### When to Use Data Migrations

- Backfilling data for new columns
- Transforming existing data
- Migrating between data formats
- Cleaning up invalid data

### Template

See `prisma/data-migrations/template.ts` for a full example.

```typescript
// prisma/data-migrations/backfill_user_display_names.ts

import { PrismaClient } from '../generated/prisma-client';

const prisma = new PrismaClient();
const BATCH_SIZE = 1000;

async function up() {
  let processed = 0;
  
  while (true) {
    const users = await prisma.user.findMany({
      where: { displayName: null },
      take: BATCH_SIZE,
    });
    
    if (users.length === 0) break;
    
    await prisma.$transaction(
      users.map(user => 
        prisma.user.update({
          where: { id: user.id },
          data: { displayName: user.email.split('@')[0] },
        })
      )
    );
    
    processed += users.length;
    console.log(`Processed ${processed} users`);
  }
}

async function down() {
  await prisma.user.updateMany({
    data: { displayName: null },
  });
}

// Run: npx tsx prisma/data-migrations/backfill_user_display_names.ts up
const command = process.argv[2];
if (command === 'up') up().finally(() => prisma.$disconnect());
else if (command === 'down') down().finally(() => prisma.$disconnect());
else console.log('Usage: npx tsx [script] up|down');
```

### Best Practices

1. **Batch processing** - Never load all records at once
2. **Idempotent** - Safe to run multiple times
3. **Resumable** - Can continue if interrupted
4. **Logged** - Output progress for monitoring
5. **Reversible** - Include `down` function
6. **Tested** - Test on staging data first

---

## Pre-Production Checklist

Before deploying a migration to production:

### Schema Review

- [ ] Migration SQL reviewed for correctness
- [ ] No breaking changes to existing functionality
- [ ] Indexes added for new query patterns
- [ ] Foreign keys have appropriate `ON DELETE` behavior

### Compatibility

- [ ] Current production code works with new schema
- [ ] New code works with old schema (for rollback)
- [ ] No column renames or type changes without multi-phase plan

### Performance

- [ ] Large table migrations use batching
- [ ] Indexes created `CONCURRENTLY` if table is large
- [ ] Estimated migration time calculated
- [ ] Migration tested on production-size dataset

### Safety

- [ ] Rollback SQL created and tested
- [ ] Database backup verified
- [ ] Maintenance window scheduled (if needed)
- [ ] On-call team notified

### Testing

- [ ] Migration tested on staging with production data copy
- [ ] Rollback tested on staging
- [ ] Application tested after migration
- [ ] Performance benchmarks run

---

## Commands Reference

```bash
# Development
npm run db:migrate:dev          # Create and apply migration
npm run db:migrate:dev -- --name my_migration  # With name
npm run db:migrate:create -- --name my_migration  # Create only

# Production
npm run db:migrate:deploy       # Apply pending migrations
npm run db:migrate:status       # Check migration status

# Utilities
npm run db:generate             # Regenerate Prisma client
npm run db:studio               # Open Prisma Studio
npm run db:seed                 # Run seed script
npm run db:migrate:reset        # Reset database (dev only)
```

---

## Related Documentation

- [Prisma Migrate Documentation](https://www.prisma.io/docs/concepts/components/prisma-migrate)
- [Zero-Downtime Migrations](https://www.prisma.io/docs/guides/database/production-troubleshooting)
- [AIVO Database Standards](../../docs/database-standards.md)
