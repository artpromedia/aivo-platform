generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma-client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserStatus {
  ACTIVE
  INVITED
  DISABLED
}

enum UserRoleEnum {
  PARENT
  LEARNER
  TEACHER
  THERAPIST
  DISTRICT_ADMIN
  PLATFORM_ADMIN
  SUPPORT
}

enum IdpProtocol {
  SAML
  OIDC
}

model User {
  id            String     @id @default(uuid()) @db.Uuid
  tenantId      String     @db.Uuid
  email         String
  phone         String?
  passwordHash  String
  externalId    String?    // IdP subject/nameId for federated users
  status        UserStatus @default(ACTIVE)
  emailVerified Boolean    @default(false)
  lastLoginAt   DateTime?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  
  // Relations
  roles                    UserRole[]
  sessions                 Session[]
  passwordResetTokens      PasswordResetToken[]
  emailVerificationTokens  EmailVerificationToken[]

  @@unique([tenantId, email])
  @@unique([tenantId, externalId])
  @@index([tenantId])
  @@index([email])
}

model UserRole {
  id          String       @id @default(uuid()) @db.Uuid
  userId      String       @db.Uuid
  role        UserRoleEnum
  contextJson Json?
  createdAt   DateTime     @default(now())

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================================================
// SSO / IDENTITY FEDERATION
// ============================================================================

/// IdP configuration for tenant SSO
model IdpConfig {
  id                    String      @id @default(uuid()) @db.Uuid
  tenantId              String      @db.Uuid
  protocol              IdpProtocol

  // Display name for the IdP (e.g., "District Google Workspace")
  name                  String
  
  // Common
  issuer                String      // IdP entity ID (SAML) or issuer URL (OIDC)
  enabled               Boolean     @default(false)
  
  // SAML-specific
  ssoUrl                String?     // IdP's SingleSignOnService URL
  sloUrl                String?     // IdP's SingleLogoutService URL (optional)
  x509Certificate       String?     @db.Text // IdP's public certificate for signature validation
  metadataXml           String?     @db.Text // Raw SAML metadata XML
  
  // OIDC-specific
  clientId              String?
  clientSecretRef       String?     // Reference to secret in KMS/Vault (not the actual secret)
  authorizationEndpoint String?
  tokenEndpoint         String?
  userinfoEndpoint      String?
  jwksUri               String?
  scopes                String[]    @default(["openid", "profile", "email"])
  
  // Claims mapping
  emailClaim            String      @default("email")
  nameClaim             String      @default("name")
  firstNameClaim        String      @default("given_name")
  lastNameClaim         String      @default("family_name")
  roleClaim             String      @default("role")
  externalIdClaim       String      @default("sub") // OIDC: sub, SAML: NameID
  
  // Role mapping configuration (JSON)
  // Example: { "Teacher": "TEACHER", "Admin": "DISTRICT_ADMIN", "Staff": "TEACHER" }
  roleMapping           Json        @default("{}")
  
  // Auto-provisioning settings
  autoProvisionUsers    Boolean     @default(false)
  defaultRole           UserRoleEnum @default(TEACHER)
  
  // Login hint template (optional, for pre-filling email domain)
  // Example: "{email}" or "{username}@district.edu"
  loginHintTemplate     String?
  
  // Allow specific user types to use this IdP
  allowedUserTypes      UserRoleEnum[] @default([TEACHER, THERAPIST, DISTRICT_ADMIN])
  
  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt
  
  // SSO attempt logs
  ssoAttempts           SsoAttempt[]
  
  @@unique([tenantId, protocol]) // One IdP config per protocol per tenant
  @@index([tenantId])
  @@index([enabled])
}

/// SSO attempt audit log
model SsoAttempt {
  id              String    @id @default(uuid()) @db.Uuid
  idpConfigId     String    @db.Uuid
  tenantId        String    @db.Uuid
  
  // Request details
  userIdentifier  String?   // Email or external ID from IdP
  ipAddress       String?
  userAgent       String?
  
  // Result
  success         Boolean
  userId          String?   @db.Uuid // If successful, the Aivo user ID
  errorCode       String?   // e.g., "INVALID_SIGNATURE", "USER_NOT_FOUND", "ASSERTION_EXPIRED"
  errorMessage    String?
  
  // Timestamps
  initiatedAt     DateTime  @default(now())
  completedAt     DateTime?
  
  idpConfig       IdpConfig @relation(fields: [idpConfigId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([idpConfigId])
  @@index([initiatedAt])
  @@index([success])
}

/// Tenant configuration (basic tenant info for SSO routing)
model Tenant {
  id              String    @id @default(uuid()) @db.Uuid
  slug            String    @unique // URL-friendly identifier, e.g., "springfield-usd"
  name            String
  domain          String?   // Primary email domain, e.g., "springfield.k12.us"
  
  // SSO settings
  ssoEnabled      Boolean   @default(false)
  ssoRequired     Boolean   @default(false) // If true, password login is disabled
  
  // Fallback admin emails (can always use password login)
  fallbackAdminEmails String[] @default([])
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([slug])
  @@index([domain])
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

/// User session for token management and device tracking
model Session {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @db.Uuid
  tenantId        String    @db.Uuid
  
  // Device/client information
  userAgent       String?
  ipAddress       String?
  deviceId        String?   // Optional device fingerprint
  deviceName      String?   // User-friendly device name
  platform        String?   // e.g., "web", "ios", "android"
  
  // Token tracking
  refreshTokenHash String?  // Hash of the current refresh token
  lastActivityAt  DateTime  @default(now())
  
  // Session lifecycle
  expiresAt       DateTime
  revokedAt       DateTime? // Set when session is explicitly revoked
  revokeReason    String?   // e.g., "logout", "password_change", "admin_revoke"
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([tenantId])
  @@index([expiresAt])
  @@index([revokedAt])
}

/// Password reset tokens
model PasswordResetToken {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @db.Uuid
  tokenHash       String    // Hashed token for security
  expiresAt       DateTime
  usedAt          DateTime? // Set when token is used
  
  createdAt       DateTime  @default(now())
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

/// Email verification tokens
model EmailVerificationToken {
  id              String    @id @default(uuid()) @db.Uuid
  userId          String    @db.Uuid
  tokenHash       String    // Hashed token for security
  email           String    // Email being verified
  expiresAt       DateTime
  verifiedAt      DateTime? // Set when verified
  
  createdAt       DateTime  @default(now())
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

/// Failed login attempts for rate limiting
model FailedLoginAttempt {
  id              String    @id @default(uuid()) @db.Uuid
  email           String
  tenantId        String?   @db.Uuid
  ipAddress       String?
  userAgent       String?
  attemptedAt     DateTime  @default(now())
  
  @@index([email, tenantId])
  @@index([ipAddress])
  @@index([attemptedAt])
}

// ============================================================================
// CONSENT MANAGEMENT (COPPA/FERPA/GDPR)
// ============================================================================

enum ConsentType {
  PARENTAL          // Parent consent for minor users (COPPA)
  STUDENT           // Student consent for educational services
  USER              // General user consent
  MARKETING         // Marketing communications consent
  ANALYTICS         // Analytics data collection consent
  THIRD_PARTY       // Third-party data sharing consent
}

enum ConsentStatus {
  PENDING           // Consent requested but not yet granted
  GRANTED           // Consent actively granted
  DENIED            // Consent explicitly denied
  EXPIRED           // Consent has expired
  REVOKED           // Consent was granted but later revoked
}

enum ConsentPurpose {
  ACCOUNT_CREATION
  EDUCATIONAL_SERVICES
  PERSONALIZATION
  ANALYTICS
  MARKETING
  THIRD_PARTY_SHARING
  RESEARCH
  AI_PROCESSING
}

/// Consent record for tracking user/parental consent
model Consent {
  id              String          @id @default(uuid()) @db.Uuid
  userId          String          @db.Uuid
  tenantId        String          @db.Uuid
  
  // Consent details
  consentType     ConsentType
  purposes        ConsentPurpose[]
  status          ConsentStatus   @default(PENDING)
  
  // Who granted consent (for parental consent, this is the parent)
  grantedById     String?         @db.Uuid
  grantedByEmail  String?
  grantedByIp     String?
  
  // Version tracking for consent terms
  termsVersion    String          @default("1.0")
  termsDocument   String?         // Reference to the consent document shown
  
  // Timestamps
  requestedAt     DateTime        @default(now())
  grantedAt       DateTime?
  expiresAt       DateTime?
  revokedAt       DateTime?
  revokedReason   String?
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  // Audit trail for consent changes
  history         ConsentHistory[]
  
  @@unique([userId, consentType, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@index([status])
  @@index([expiresAt])
}

/// Audit trail for consent changes
model ConsentHistory {
  id              String          @id @default(uuid()) @db.Uuid
  consentId       String          @db.Uuid
  
  // Change details
  previousStatus  ConsentStatus
  newStatus       ConsentStatus
  changedById     String?         @db.Uuid
  changedByIp     String?
  reason          String?
  
  createdAt       DateTime        @default(now())
  
  consent         Consent         @relation(fields: [consentId], references: [id], onDelete: Cascade)
  
  @@index([consentId])
  @@index([createdAt])
}

/// Age verification records
model AgeVerification {
  id              String          @id @default(uuid()) @db.Uuid
  userId          String          @db.Uuid
  tenantId        String          @db.Uuid
  
  // Verification details
  dateOfBirth     DateTime?
  verifiedAge     Int?            // Verified age at time of verification
  isMinor         Boolean         @default(false)
  coppaApplicable Boolean         @default(false) // Under 13
  
  // Verification method
  method          String          // e.g., "self_declaration", "parent_verified", "document"
  verifiedById    String?         @db.Uuid // Parent who verified, if applicable
  
  // Timestamps
  verifiedAt      DateTime        @default(now())
  expiresAt       DateTime?       // For periodic re-verification
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@index([isMinor])
}

/// MFA configuration for users
model MfaConfig {
  id              String          @id @default(uuid()) @db.Uuid
  userId          String          @db.Uuid
  tenantId        String          @db.Uuid
  
  // MFA settings
  enabled         Boolean         @default(false)
  method          String          @default("totp") // totp, sms, email
  
  // TOTP secret (encrypted)
  totpSecretEncrypted String?
  totpVerifiedAt  DateTime?
  
  // Backup codes (hashed)
  backupCodes     String[]        @default([])
  backupCodesGeneratedAt DateTime?
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
}

/// MFA challenges for verification
model MfaChallenge {
  id              String          @id @default(uuid()) @db.Uuid
  userId          String          @db.Uuid
  sessionId       String          @db.Uuid
  
  // Challenge details
  method          String          // totp, sms, email
  code            String?         // For SMS/email codes (hashed)
  attempts        Int             @default(0)
  maxAttempts     Int             @default(3)
  
  // Status
  verified        Boolean         @default(false)
  verifiedAt      DateTime?
  
  // Timestamps
  expiresAt       DateTime
  createdAt       DateTime        @default(now())
  
  @@index([userId])
  @@index([sessionId])
  @@index([expiresAt])
}
