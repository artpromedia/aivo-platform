# .github/workflows/deploy-production.yml
# Deploy to Production Environment
# Runs on release publication or manual dispatch with approval

name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (must be a valid release tag)'
        required: true
      skip_approval:
        description: 'Skip manual approval (emergency only)'
        required: false
        default: 'false'

env:
  GKE_CLUSTER: aivo-production
  GKE_ZONE: us-central1
  PROJECT_ID: aivo-platform
  NAMESPACE: aivo-prod

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VALIDATE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  validate:
    name: Validate Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          
          # Validate version format
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            echo "âŒ Invalid version format: $VERSION"
            echo "Expected format: vX.Y.Z or vX.Y.Z-suffix"
            exit 1
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "âœ… Valid version: $VERSION"

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_PROD_SA_KEY }}

      - name: Verify images exist
        run: |
          SERVICES=(
            "auth-svc"
            "content-svc"
            "session-svc"
            "assessment-svc"
            "analytics-svc"
            "ai-orchestrator"
            "notify-svc"
            "messaging-svc"
            "goal-svc"
            "focus-svc"
            "personalization-svc"
            "billing-svc"
            "consent-svc"
          )
          
          MISSING=0
          for service in "${SERVICES[@]}"; do
            IMAGE="gcr.io/${{ env.PROJECT_ID }}/${service}:${{ steps.version.outputs.version }}"
            echo "Checking $IMAGE..."
            if gcloud container images describe "$IMAGE" &>/dev/null; then
              echo "âœ… Found: $service"
            else
              echo "âŒ Missing: $service"
              MISSING=$((MISSING + 1))
            fi
          done
          
          if [[ $MISSING -gt 0 ]]; then
            echo "âŒ $MISSING images are missing. Please build them first."
            exit 1
          fi
          
          echo "âœ… All images verified!"

      - name: Check staging deployment
        run: |
          echo "Verifying version ${{ steps.version.outputs.version }} was deployed to staging..."
          # In a real scenario, this would check a deployment tracking system
          # For now, we'll just log the check
          echo "âœ… Staging verification passed (manual check required)"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # APPROVAL GATE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  approval:
    name: Production Approval
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.skip_approval != 'true'
    environment: production-approval
    steps:
      - name: Approval gate
        run: |
          echo "ğŸ” Production deployment approved"
          echo "Version: ${{ needs.validate.outputs.version }}"
          echo "Approved by: ${{ github.actor }}"
          echo "Time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEPLOY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, approval]
    if: always() && needs.validate.result == 'success' && (needs.approval.result == 'success' || needs.approval.result == 'skipped')
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_PROD_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}

      - name: Create deployment record
        run: |
          echo "ğŸ“ Creating deployment record..."
          echo "Version: ${{ needs.validate.outputs.version }}"
          echo "Deployer: ${{ github.actor }}"
          echo "Time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "Run ID: ${{ github.run_id }}"

      - name: Setup Kustomize
        uses: imranismail/setup-kustomize@v2

      - name: Update image tags
        run: |
          cd infra/k8s/overlays/production
          
          SERVICES=(
            "auth-svc"
            "content-svc"
            "session-svc"
            "assessment-svc"
            "analytics-svc"
            "ai-orchestrator"
            "notify-svc"
            "messaging-svc"
            "goal-svc"
            "focus-svc"
            "personalization-svc"
            "billing-svc"
            "consent-svc"
          )
          
          for service in "${SERVICES[@]}"; do
            kustomize edit set image gcr.io/${{ env.PROJECT_ID }}/${service}=gcr.io/${{ env.PROJECT_ID }}/${service}:${{ needs.validate.outputs.version }} 2>/dev/null || true
          done

      - name: Deploy canary (10% traffic)
        run: |
          echo "::group::Deploying canary"
          kubectl apply -f infra/k8s/overlays/production/canary/ -n ${{ env.NAMESPACE }} 2>/dev/null || echo "No canary manifests found, proceeding with full deployment"
          echo "::endgroup::"
          
          # Check if canary pods exist
          if kubectl get deployment -l deployment-type=canary -n ${{ env.NAMESPACE }} 2>/dev/null | grep -q canary; then
            echo "Waiting for canary pods..."
            kubectl rollout status deployment --all -l deployment-type=canary -n ${{ env.NAMESPACE }} --timeout=300s
            
            echo "ğŸ” Canary deployed. Monitoring for 5 minutes..."
            sleep 300
            
            # Check error rates (simplified check)
            echo "Checking canary health..."
            UNHEALTHY=$(kubectl get pods -l deployment-type=canary -n ${{ env.NAMESPACE }} -o json | jq '[.items[] | select(.status.phase != "Running")] | length')
            
            if [[ "$UNHEALTHY" -gt 0 ]]; then
              echo "âŒ Canary has unhealthy pods. Rolling back..."
              kubectl delete -f infra/k8s/overlays/production/canary/ -n ${{ env.NAMESPACE }} || true
              exit 1
            fi
            
            echo "âœ… Canary healthy. Proceeding with full rollout."
          else
            echo "No canary deployment configured, proceeding with full rollout"
          fi

      - name: Full rollout
        run: |
          echo "::group::Applying production manifests"
          kustomize build infra/k8s/overlays/production | kubectl apply -f -
          echo "::endgroup::"
          
          echo "::group::Waiting for rollout"
          kubectl rollout status deployment --all -n ${{ env.NAMESPACE }} --timeout=900s
          echo "::endgroup::"
          
          # Remove canary if exists
          kubectl delete -f infra/k8s/overlays/production/canary/ -n ${{ env.NAMESPACE }} --ignore-not-found || true

      - name: Verify deployment
        run: |
          echo "::group::Pod Status"
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide
          echo "::endgroup::"
          
          echo "::group::Deployment Status"
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo "::endgroup::"

      - name: Run smoke tests
        run: |
          echo "Running production smoke tests..."
          sleep 60
          
          # Basic health checks
          ENDPOINTS=(
            "https://api.aivo.ai/health"
            "https://api.aivo.ai/api/v1/status"
          )
          
          for endpoint in "${ENDPOINTS[@]}"; do
            echo "Checking $endpoint..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint" --max-time 10) || HTTP_CODE="000"
            if [[ "$HTTP_CODE" -ge 200 && "$HTTP_CODE" -lt 300 ]]; then
              echo "âœ… $endpoint returned $HTTP_CODE"
            else
              echo "âš ï¸ $endpoint returned $HTTP_CODE"
            fi
          done

      - name: Update deployment record
        if: always()
        run: |
          echo "ğŸ“ Updating deployment record..."
          echo "Status: ${{ job.status }}"
          echo "Completed: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"

      - name: Notify on success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ğŸš€ Production deployment successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ğŸš€ *Production Deployment Successful*\n\n*Version:* `${{ needs.validate.outputs.version }}`\n*Deployed by:* ${{ github.actor }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": { "type": "plain_text", "text": "View Production" },
                      "url": "https://aivo.ai"
                    },
                    {
                      "type": "button",
                      "text": { "type": "plain_text", "text": "View API" },
                      "url": "https://api.aivo.ai/health"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Notify on failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "ğŸš¨ PRODUCTION DEPLOYMENT FAILED",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "ğŸš¨ *PRODUCTION DEPLOYMENT FAILED*\n\n*Version:* `${{ needs.validate.outputs.version }}`\n*Attempted by:* ${{ github.actor }}\n\n@channel Please investigate immediately!"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": { "type": "plain_text", "text": "View Logs" },
                      "style": "danger",
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button",
                      "text": { "type": "plain_text", "text": "Runbook" },
                      "url": "https://docs.aivo.ai/runbooks/deployment-failure"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_ALERT_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # RUN MIGRATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  run-migrations:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_PROD_SA_KEY }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v1
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}

      - name: Run migrations
        run: |
          # Create migration job
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-migrate-prod-${{ github.run_number }}
            namespace: ${{ env.NAMESPACE }}
          spec:
            ttlSecondsAfterFinished: 600
            backoffLimit: 3
            template:
              spec:
                restartPolicy: Never
                containers:
                  - name: migrate
                    image: gcr.io/${{ env.PROJECT_ID }}/db-migrations:${{ needs.validate.outputs.version }}
                    command: ["npm", "run", "db:migrate:deploy"]
                    envFrom:
                      - secretRef:
                          name: database-credentials
                    resources:
                      requests:
                        memory: "256Mi"
                        cpu: "100m"
                      limits:
                        memory: "512Mi"
                        cpu: "500m"
          EOF
          
          # Wait for completion
          kubectl wait --for=condition=complete job/db-migrate-prod-${{ github.run_number }} -n ${{ env.NAMESPACE }} --timeout=600s
          
          # Get logs
          echo "::group::Migration Logs"
          kubectl logs job/db-migrate-prod-${{ github.run_number }} -n ${{ env.NAMESPACE }}
          echo "::endgroup::"
          
          # Cleanup
          kubectl delete job db-migrate-prod-${{ github.run_number }} -n ${{ env.NAMESPACE }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CREATE GITHUB DEPLOYMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  create-github-deployment:
    name: Create GitHub Deployment
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: success()
    steps:
      - name: Create GitHub deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: production
          ref: ${{ needs.validate.outputs.version }}
          description: "Production deployment of ${{ needs.validate.outputs.version }}"
